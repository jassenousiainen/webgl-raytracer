(()=>{"use strict";var e={84:(e,n,t)=>{var i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var r=Math.PI/180;function o(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function a(e,n){var t=n[0],i=n[1],r=n[2],o=n[3],a=n[4],s=n[5],l=n[6],c=n[7],f=n[8],d=n[9],u=n[10],h=n[11],m=n[12],g=n[13],p=n[14],v=n[15],b=t*s-i*a,_=t*l-r*a,y=t*c-o*a,x=i*l-r*s,L=i*c-o*s,S=r*c-o*l,E=f*g-d*m,I=f*p-u*m,P=f*v-h*m,w=d*p-u*g,C=d*v-h*g,A=u*v-h*p,R=b*A-_*C+y*w+x*P-L*I+S*E;return R?(R=1/R,e[0]=(s*A-l*C+c*w)*R,e[1]=(r*C-i*A-o*w)*R,e[2]=(g*S-p*L+v*x)*R,e[3]=(u*L-d*S-h*x)*R,e[4]=(l*P-a*A-c*I)*R,e[5]=(t*A-r*P+o*I)*R,e[6]=(p*y-m*S-v*_)*R,e[7]=(f*S-u*y+h*_)*R,e[8]=(a*C-s*P+c*E)*R,e[9]=(i*P-t*C-o*E)*R,e[10]=(m*L-g*y+v*b)*R,e[11]=(d*y-f*L-h*b)*R,e[12]=(s*I-a*w-l*E)*R,e[13]=(t*w-i*I+r*E)*R,e[14]=(g*_-m*x-p*b)*R,e[15]=(f*x-d*_+u*b)*R,e):null}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var s=function(e,n,t){var i=n[0],r=n[1],o=n[2],a=n[3],s=n[4],l=n[5],c=n[6],f=n[7],d=n[8],u=n[9],h=n[10],m=n[11],g=n[12],p=n[13],v=n[14],b=n[15],_=t[0],y=t[1],x=t[2],L=t[3];return e[0]=_*i+y*s+x*d+L*g,e[1]=_*r+y*l+x*u+L*p,e[2]=_*o+y*c+x*h+L*v,e[3]=_*a+y*f+x*m+L*b,_=t[4],y=t[5],x=t[6],L=t[7],e[4]=_*i+y*s+x*d+L*g,e[5]=_*r+y*l+x*u+L*p,e[6]=_*o+y*c+x*h+L*v,e[7]=_*a+y*f+x*m+L*b,_=t[8],y=t[9],x=t[10],L=t[11],e[8]=_*i+y*s+x*d+L*g,e[9]=_*r+y*l+x*u+L*p,e[10]=_*o+y*c+x*h+L*v,e[11]=_*a+y*f+x*m+L*b,_=t[12],y=t[13],x=t[14],L=t[15],e[12]=_*i+y*s+x*d+L*g,e[13]=_*r+y*l+x*u+L*p,e[14]=_*o+y*c+x*h+L*v,e[15]=_*a+y*f+x*m+L*b,e};function l(e,n,t){var i=e.createShader(n);if(e.shaderSource(i,t),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS))return i;console.log(e.getShaderInfoLog(i)),e.deleteShader(i)}function c(e){var n=e.createTexture();return e.bindTexture(e.TEXTURE_2D,n),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),n}function f(e,n,t){e.canvas.width=n,e.canvas.height=t,e.viewport(0,0,e.canvas.width,e.canvas.height)}var d=t(675),u=t(574);const h=JSON.parse('{"nS":{"x":0,"y":0,"z":16,"fx":0,"tW":-0.05,"Bp":0.7,"On":0.1,"NC":50},"H":[{"x":0,"y":3.999999,"z":0,"r":1,"g":1,"b":1,"sizeX":1,"sizeY":1,"brightness":100,"spotSize":0.001,"spotIntensity":1.5,"rotate":false,"enabled":true},{"x":-3.3,"y":2.5,"z":0,"r":1,"g":1,"b":1,"sizeX":0.3,"sizeY":0.3,"brightness":100,"spotSize":0.9,"spotIntensity":0,"rotate":true,"enabled":false}],"vi":[{"x":1.25,"y":-1.5,"z":-1.5,"r":0.9,"g":0.5,"b":0.9,"rr":0,"rg":0,"rb":0,"sr":1,"sg":1,"sb":1,"roughness":1},{"x":2.5,"y":-3.2,"z":-1.5,"r":0,"g":0,"b":0,"rr":1,"rg":1,"rb":1,"sr":1,"sg":1,"sb":1,"roughness":1},{"x":0,"y":-3.2,"z":-1.5,"r":0.9,"g":0.1,"b":0.1,"rr":0,"rg":0,"rb":0,"sr":0,"sg":0,"sb":0,"roughness":0.35},{"x":-2.5,"y":-3.2,"z":-1.5,"r":0.1,"g":0.9,"b":0.9,"rr":0,"rg":0,"rb":0,"sr":0,"sg":0,"sb":0,"roughness":0.5}],"Rm":[{"x":0,"y":1,"z":0,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":-4,"enabled":true,"desc":"floor"},{"x":0,"y":-1,"z":0,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":4,"enabled":true,"desc":"ceiling"},{"x":-1,"y":0,"z":0,"r":1,"g":0.1,"b":0.1,"specular":0,"roughness":1,"offset":4,"enabled":true,"desc":"right wall"},{"x":1,"y":0,"z":0,"r":0.1,"g":1,"b":0.1,"specular":0,"roughness":1,"offset":-4,"enabled":true,"desc":"left wall"},{"x":0,"y":0,"z":1,"r":0.9,"g":0.9,"b":0.5,"specular":0,"roughness":0.25,"offset":-4,"enabled":true,"desc":"back wall"},{"x":0,"y":0,"z":-1,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":4,"enabled":false,"desc":"front wall"}]}');var m=document.getElementById("fps"),g=!0,p=!0,v=!1,b=!1,_=!1,y=!1,x=!1,L=0,S=0,E=0,I=0,P=document.querySelector("#canvas"),w=P.getContext("webgl2",{powerPreference:"high-performance",antialias:!1,alpha:!0,stencil:!1,depth:!1,desynchronized:!1,preserveDrawingBuffer:!1}),C=function(e,n,t){console.log("COMPILING SHADERS");var i=l(e,e.VERTEX_SHADER,n),r=l(e,e.FRAGMENT_SHADER,t);console.log("CREATING PROGRAM"),f(e,1280,720),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT);var o=function(e,n,t){var i=e.createProgram();if(e.attachShader(i,n),e.attachShader(i,t),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS))return i;console.log(e.getProgramInfoLog(i)),e.deleteProgram(i)}(e,i,r);return e.useProgram(o),console.log("FINISH"),o}(w,d,u),A=w.getUniformLocation(C,"enableTAA"),R=w.getUniformLocation(C,"randomseed"),T=(w.getUniformLocation(C,"sphereCenters[0]"),w.getUniformLocation(C,"u_texture")),z=c(w);w.texImage2D(w.TEXTURE_2D,0,w.RGBA,w.canvas.width,w.canvas.height,0,w.RGBA,w.UNSIGNED_BYTE,null);var N=w.createFramebuffer();w.bindFramebuffer(w.DRAW_FRAMEBUFFER,N),w.framebufferTexture2D(w.DRAW_FRAMEBUFFER,w.COLOR_ATTACHMENT0,w.TEXTURE_2D,z,0);var M=c(w);w.texImage2D(w.TEXTURE_2D,0,w.RGBA,w.canvas.width,w.canvas.height,0,w.RGBA,w.UNSIGNED_BYTE,null);var k=w.createFramebuffer();w.bindFramebuffer(w.DRAW_FRAMEBUFFER,k),w.framebufferTexture2D(w.DRAW_FRAMEBUFFER,w.COLOR_ATTACHMENT0,w.TEXTURE_2D,M,0);var U=!0,B=!0,D=50,F=1,G=!0,X=9,H=!0,q=!1,V=1.5,O=0,j=h.nS.On,Y=h.nS.NC,W=h.nS.Bp,K=h.nS.x,Z=h.nS.y,J=h.nS.z,Q=h.nS.fx,$=h.nS.tW,ee=o(),ne=o(),te=o(),ie=o(),re=o(),oe=o();function ae(e){var n,t,i,r;b&&(K+=4*e*Math.cos($)*Math.cos(Q+Math.PI/2),Z+=4*e*Math.sin($),J-=4*e*Math.cos($)*Math.sin(Q+Math.PI/2)),y&&(K-=4*e*Math.cos($)*Math.cos(Q+Math.PI/2),Z-=4*e*Math.sin($),J+=4*e*Math.cos($)*Math.sin(Q+Math.PI/2)),_&&(K+=4*e*Math.cos(Q+Math.PI),J-=4*e*Math.sin(Q+Math.PI)),x&&(K+=4*e*Math.cos(Q),J-=4*e*Math.sin(Q)),function(e,n,t,i,r){var o,a=1/Math.tan(n/2);e[0]=a/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=r&&r!==1/0?(o=1/(i-r),e[10]=(r+i)*o,e[14]=2*r*i*o):(e[10]=-1,e[14]=-2*i)}(ee,W,w.canvas.width/w.canvas.height,j,Y),n=ne,t=Q,i=Math.sin(t),r=Math.cos(t),n[0]=r,n[1]=0,n[2]=-i,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=i,n[9]=0,n[10]=r,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,function(e,n){var t=Math.sin(n),i=Math.cos(n);e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=t,e[7]=0,e[8]=0,e[9]=-t,e[10]=i,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(te,$),function(e,n){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1}(ie,[K,Z,J]),s(re,ne,te),s(re,ie,re),a(re,re),s(oe,ee,re),a(oe,oe),w.uniform1f(w.getUniformLocation(C,"near"),j),w.uniform1f(w.getUniformLocation(C,"far"),Y),w.uniformMatrix4fv(w.getUniformLocation(C,"invprojview"),!1,oe)}function se(){for(var e=[],n=0;n<h.Rm.length;n++)h.Rm[n].enabled&&e.push(h.Rm[n]);var t=e.length;w.uniform1i(w.getUniformLocation(C,"numPlanes"),t);for(var i=0;i<t;i++){var r=w.getUniformLocation(C,"planeOffsets["+i+"]"),o=w.getUniformLocation(C,"planeNormals["+i+"]"),a=w.getUniformLocation(C,"planeColors["+i+"]"),s=w.getUniformLocation(C,"planeSpecular["+i+"]"),l=w.getUniformLocation(C,"planeRoughness["+i+"]");w.uniform1f(r,e[i].offset),w.uniform3f(o,e[i].x,e[i].y,e[i].z),w.uniform3f(a,e[i].r,e[i].g,e[i].b),w.uniform1f(s,e[i].specular),w.uniform1f(l,e[i].roughness)}}function le(){var e=h.H.filter((function(e){return e.enabled})),n=e.length;w.uniform1i(w.getUniformLocation(C,"numLights"),n);for(var t=0;t<n;t++){var i=e[t],r=w.getUniformLocation(C,"lightPos["+t+"]"),o=w.getUniformLocation(C,"lightSize["+t+"]"),a=w.getUniformLocation(C,"lightBrightness["+t+"]"),s=w.getUniformLocation(C,"lightSpot["+t+"]");w.uniform3f(r,i.x,i.y,i.z),w.uniform2f(o,G?i.sizeX:0,G?i.sizeY:0),w.uniform3f(a,i.r*i.brightness,i.g*i.brightness,i.b*i.brightness),w.uniform2f(s,i.spotSize,i.spotIntensity)}}function ce(){w.uniform3f(w.getUniformLocation(C,"ambientLight"),.01,.01,.01),w.uniform1i(w.getUniformLocation(C,"enableGI"),U),w.uniform1i(w.getUniformLocation(C,"enableRefGI"),B),w.uniform1i(w.getUniformLocation(C,"indirectSamples"),D),w.uniform1i(w.getUniformLocation(C,"rayBounces"),F);var e=Math.floor(Math.sqrt(X));w.uniform1f(w.getUniformLocation(C,"shadowDim"),e),w.uniform1i(w.getUniformLocation(C,"shadowSamples"),Math.pow(e,2)),w.uniform1i(w.getUniformLocation(C,"enablePlaneBacksides"),H),w.uniform1i(w.getUniformLocation(C,"enablePlaneMirrors"),q),w.uniform2f(w.getUniformLocation(C,"attenuationFactor"),V,O)}function fe(){P.style.width=window.innerWidth,P.style.height=window.innerHeight;var e=Math.floor(window.innerWidth*window.devicePixelRatio),n=Math.floor(window.innerHeight*window.devicePixelRatio);w.bindTexture(w.TEXTURE_2D,z),w.texImage2D(w.TEXTURE_2D,0,w.RGBA,e,n,0,w.RGBA,w.UNSIGNED_BYTE,null),w.bindTexture(w.TEXTURE_2D,null),w.bindTexture(w.TEXTURE_2D,M),w.texImage2D(w.TEXTURE_2D,0,w.RGBA,e,n,0,w.RGBA,w.UNSIGNED_BYTE,null),w.bindTexture(w.TEXTURE_2D,null),f(w,e,n),ae(),E=-1}function de(e,n){var t=document.getElementById("lightcontrols"),i="\n        <br>\n        <b>light ".concat(e+1,'</b><br>\n        <input type="checkbox" ').concat(n[e].enabled&&"checked",' id="').concat(e,'" class="light-enable"> on/off<br>\n        <table class="sliders">\n            <tr>\n                <td><label>Bright:</label></td>\n                <td><input type="range" min="0" max="200" step="0.1" value="').concat(n[e].brightness,'" id="').concat(e,'" class="light-brightness"></td>\n            </tr>\n            <tr>\n                <td><label>Spot size:</label></td>\n                <td><input type="range" min="0" max="1" step="0.01" value="').concat(1-n[e].spotSize,'" id="').concat(e,'" class="light-spotsize"></td>\n            </tr>\n            <tr>\n                <td><label>Spot falloff:</label></td>\n                <td><input type="range" min="0" max="4" step="0.01" value="').concat(n[e].spotIntensity,'" id="').concat(e,'" class="light-spotintensity"></td>\n            </tr>\n            <tr>\n                <td><label>r:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(e,'r" class="light-color"></td>\n            </tr>\n            <tr>\n                <td><label>g:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(e,'g" class="light-color"></td>\n            </tr>\n            <tr>\n                <td><label>b:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(e,'b" class="light-color"></td>\n            </tr>\n                <td><label>sizeX:</label></td>\n                <td><input type="range" min="0" max="3" step="0.01" value="').concat(n[e].sizeX,'" id="').concat(e,'x" class="light-size"></td>\n            <tr>\n                <td><label>sizeY:</label></td>\n                <td><input type="range" min="0" max="3" step="0.01" value="').concat(n[e].sizeY,'" id="').concat(e,'y" class="light-size"></td>\n            </tr>\n        </table>');t.insertAdjacentHTML("beforeend",i)}function ue(e,n){var t=document.getElementById("planecontrols"),i='\n        <input type="checkbox" id="'.concat(e,'" class="plane-enable" ').concat(n[e].enabled&&"checked","><b>").concat(n[e].desc,"</b><br>");t.insertAdjacentHTML("beforeend",i)}fe(),se(),function(){var e=h.vi.length;w.uniform1i(w.getUniformLocation(C,"numSpheres"),e);for(var n=0;n<e;n++){var t=h.vi[n],i=w.getUniformLocation(C,"sphereCenters["+n+"]"),r=w.getUniformLocation(C,"sphereColors["+n+"]"),o=w.getUniformLocation(C,"reflectiveColors["+n+"]"),a=w.getUniformLocation(C,"sphereSpecColors["+n+"]"),s=w.getUniformLocation(C,"sphereRoughness["+n+"]");w.uniform3f(i,t.x,t.y,t.z),w.uniform3f(r,t.r,t.g,t.b),w.uniform3f(o,t.rr,t.rg,t.rb),w.uniform3f(a,t.sr,t.sg,t.sb),w.uniform1f(s,t.roughness)}}(),le(),ce(),function e(n){L=(n=.001*(n||0))-S,S=n,0!=(E+=1)&&(I+=1/L);var t,r,o,a,l,c,f=p&&0!=E;if((v||b||_||y||x)&&(ae(L),v=!1,f=!1),f&&(t=1/w.canvas.width,r=1/w.canvas.height,1,0,0,0,0,1,0,0,0,0,1,0,a=(2*Math.random()-1)*t,l=(2*Math.random()-1)*r,0,1,(c=new i(16))[0]=1,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=1,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[10]=1,c[11]=0,c[12]=a,c[13]=l,c[14]=0,c[15]=1,s(o=c,oe,o),w.uniformMatrix4fv(w.getUniformLocation(C,"invprojview"),!1,o)),w.uniform1i(A,f),w.uniform1f(R,Math.random()),p){var d=g?N:k;w.bindFramebuffer(w.DRAW_FRAMEBUFFER,d),w.bindTexture(w.TEXTURE_2D,g?M:z),w.clearColor(0,0,0,1),w.clear(w.COLOR_BUFFER_BIT),w.uniform1i(T,0),w.drawArrays(w.TRIANGLES,0,3),w.bindFramebuffer(w.READ_FRAMEBUFFER,d),w.bindFramebuffer(w.DRAW_FRAMEBUFFER,null),w.blitFramebuffer(0,0,w.canvas.width,w.canvas.height,0,0,w.canvas.width,w.canvas.height,w.COLOR_BUFFER_BIT,w.NEAREST),g=!g}else w.bindFramebuffer(w.DRAW_FRAMEBUFFER,null),w.drawArrays(w.TRIANGLES,0,3);50==E&&(m.innerText=Math.round(I/50),I=0,E=0),requestAnimationFrame(e)}();for(var he=0;he<h.H.length;he++)de(he,h.H);for(var me=0;me<h.Rm.length;me++)ue(me,h.Rm);function ge(e,n){switch(e){case"KeyW":b=n;break;case"KeyS":y=n;break;case"KeyA":_=n;break;case"KeyD":x=n}}window.addEventListener("resize",fe),document.addEventListener("mousedown",(function(e){e.target.closest(".controls")||2==e.button&&(document.pointerLockElement===e.target?document.exitPointerLock():e.target.requestPointerLock())})),document.addEventListener("mousemove",(function(e){var n;"canvas"===(null===(n=document.pointerLockElement)||void 0===n?void 0:n.id)&&(Q-=.0015*e.movementX,$-=.0015*e.movementY,v=!0)})),document.addEventListener("keydown",(function(e){return ge(e.code,!0)})),document.addEventListener("keyup",(function(e){return ge(e.code,!1)})),document.getElementById("enableTAA").addEventListener("input",(function(e){p=e.target.checked,fe()})),document.getElementById("enableGI").addEventListener("input",(function(e){U=e.target.checked,ce()})),document.getElementById("enableRefGI").addEventListener("input",(function(e){B=e.target.checked,ce()})),document.getElementById("indirectsamples").addEventListener("input",(function(e){D=e.target.value,ce()})),document.getElementById("directsamples").addEventListener("input",(function(e){X=e.target.value*e.target.value,ce()})),document.getElementById("reflectionbounces").addEventListener("input",(function(e){F=e.target.value,ce()})),document.getElementById("fov").addEventListener("input",(function(e){var n;n=e.target.value,W=n*r,ae()})),document.getElementById("arealightsenable").addEventListener("input",(function(e){G=e.target.checked,le()})),document.querySelectorAll(".attenuation").forEach((function(e){e.addEventListener("input",(function(e){"quadratic"===e.target.id?V=e.target.value:"linear"===e.target.id&&(O=e.target.value),ce()}))})),document.querySelectorAll(".light-enable").forEach((function(e){e.addEventListener("input",(function(e){h.H[e.target.id].enabled=e.target.checked,le()}))})),document.querySelectorAll(".light-brightness").forEach((function(e){e.addEventListener("input",(function(e){h.H[e.target.id].brightness=e.target.value,le()}))})),document.querySelectorAll(".light-spotsize").forEach((function(e){e.addEventListener("input",(function(e){h.H[e.target.id].spotSize=1-e.target.value,le()}))})),document.querySelectorAll(".light-spotintensity").forEach((function(e){e.addEventListener("input",(function(e){h.H[e.target.id].spotIntensity=e.target.value,le()}))})),document.querySelectorAll(".light-color").forEach((function(e){e.addEventListener("input",(function(e){var n=h.H[e.target.id[0]];"r"===e.target.id[1]?n.r=e.target.value:"g"===e.target.id[1]?n.g=e.target.value:"b"===e.target.id[1]&&(n.b=e.target.value),le()}))})),document.querySelectorAll(".light-size").forEach((function(e){e.addEventListener("input",(function(e){var n=h.H[e.target.id[0]];"x"===e.target.id[1]?n.sizeX=e.target.value:"y"===e.target.id[1]&&(n.sizeY=e.target.value),le()}))})),document.querySelectorAll(".plane-enable").forEach((function(e){e.addEventListener("input",(function(e){h.Rm[e.target.id].enabled=e.target.checked,se()}))})),document.getElementById("planebacksides").addEventListener("input",(function(e){H=e.target.checked,ce()})),document.getElementById("enablemirrorworld").addEventListener("input",(function(e){q=e.target.checked,H=!1,document.getElementById("planebacksides").checked=!1;for(var n=0;n<h.Rm.length;n++)h.Rm[n].enabled=!0;document.querySelectorAll(".plane-enable").forEach((function(e){e.checked=!0})),B=!1,document.getElementById("enableRefGI").checked=!1,F=5,document.getElementById("reflectionbounces").value=5,document.getElementById("reflectionbounces").nextElementSibling.value=5,se(),ce()})),document.getElementById("increasedlimits").addEventListener("input",(function(e){document.getElementById("indirectsamples").setAttribute("max",200),document.getElementById("reflectionbounces").setAttribute("max",100),document.getElementById("fov").setAttribute("max",179),document.getElementById("fov").setAttribute("min",1)}))},424:(e,n,t)=>{t.d(n,{Z:()=>s});var i=t(81),r=t.n(i),o=t(645),a=t.n(o)()(r());a.push([e.id,"/* ----- COLORS ----- */\n:root {\n    --blue: #007bff;\n    /*--blue: #2e5bff;*/\n    --darkblue: #1374dc;\n    --blue-neon: #0dffff;\n    --teal: #11cdef;\n    --lightgreen: #00d774;\n    --orange: #fd7e14;\n    --darkorange: #e07217;\n    --gray1: #f4f5f7;\n    --gray2: #e2e6ea;\n    --gray3: #6c757d;\n    --gray4: #343a40;\n    --green: #28a745;\n    --green-dark: #1c8935;\n    --red: #dc3545;\n    --red-dark: #c42e3d;\n    --red-bright: #ff3355;\n    --red-light: #ff6384;\n    --purple-light: #5e72e4;\n    --purple: #6f42c1;\n    --purple-dark: rgb(112, 48, 160);\n}\n/*------------------------*/\n\nhtml {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n}\n\nbody {\n    margin: 0;\n    padding: 0;\n    background-color: rgb(0, 0, 0);\n    overflow: hidden;\n}\n/*\ncanvas {\n    width: 100%;\n    height: 100%;\n}\n*/\n.controls {\n    position: absolute;\n    top: 1em;\n    right: 1em;\n    width: 250px;\n    padding: 0 0.2em 1em 1em;\n    background-color: rgb(255 255 255 / 60%);\n    border-radius: 15px;\n    max-height: 95%;\n    overflow-y: scroll;\n    overflow-x: hidden;\n}\n\n.controls::-webkit-scrollbar-track {\n    /*-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);*/\n \t/*border-radius: 10px;*/\n}\n.controls::-webkit-scrollbar {\n \twidth: 1em;\n}\n.controls::-webkit-scrollbar-thumb {\n    background-color: var(--blue);\n    border: 5px solid transparent;\n    border-radius: 15px;\n    background-clip: padding-box;\n}\n.controls::-webkit-scrollbar-thumb:hover {\n\tbackground-color: var(--darkblue);\n}\n\n.controls .section {\n    border-bottom: solid 1px rgb(255 255 255 / 60%);\n    margin: 1em 0 0 0;\n    padding: 0 0 1em;\n}\n\n.controls h3 {\n    padding: 0;\n    margin: 0 0 0.5em 0;\n    color: #005aff;\n    font-weight: 600;\n}\n\n.controls output {\n    color: #005aff;\n}\n\n.controls .deg-sign {\n    color: #005aff;\n}\n\n.controls .slider_container {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\ntable.sliders {\n    width: 100%;\n}\n\n.sliders input {\n    width: 100%;\n}\n\n#fps-container {\n    position: absolute;\n    top: 1em;\n    left: 1em;\n    color: white;\n}\n\n/* ----- Toggle switch ----- */\n/* The switch - the box around the slider */\n.switch {\n    position: relative;\n  }\n  /* Hide default HTML checkbox */\n  .switch input {\n    position: absolute;\n    opacity: 0;\n    width: 0;\n    height: 0;\n  }\n  /* The slider */\n  .slider {\n    border-radius: 10px;\n    position: relative;\n    display: inline-block;\n    cursor: pointer;\n    vertical-align: middle;\n    height: 15px;\n    width: 34px;\n    background-color: var(--gray2);\n    -webkit-transition: 0.4s;\n    transition: 0.4s;\n  }\n  .slider:before {\n    position: absolute;\n    content: \"\";\n    height: 11px;\n    width: 11px;\n    left: 3px;\n    bottom: 2px;\n    background-color: white;\n    -webkit-transition: 0.4s;\n    transition: 0.4s;\n    box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.21);\n    border-radius: 5px;\n  }\n  input:checked + .slider {\n    background-color: var(--blue);\n  }\n  input:checked + .slider.del {\n    background-color: var(--red-bright);\n  }\n  input:checked + .slider:before {\n    transform: translateX(17px);\n  }\n  /* ----------------------- */",""]);const s=a},645:e=>{e.exports=function(e){var n=[];return n.toString=function(){return this.map((function(n){var t="",i=void 0!==n[5];return n[4]&&(t+="@supports (".concat(n[4],") {")),n[2]&&(t+="@media ".concat(n[2]," {")),i&&(t+="@layer".concat(n[5].length>0?" ".concat(n[5]):""," {")),t+=e(n),i&&(t+="}"),n[2]&&(t+="}"),n[4]&&(t+="}"),t})).join("")},n.i=function(e,t,i,r,o){"string"==typeof e&&(e=[[null,e,void 0]]);var a={};if(i)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(a[l]=!0)}for(var c=0;c<e.length;c++){var f=[].concat(e[c]);i&&a[f[0]]||(void 0!==o&&(void 0===f[5]||(f[1]="@layer".concat(f[5].length>0?" ".concat(f[5]):""," {").concat(f[1],"}")),f[5]=o),t&&(f[2]?(f[1]="@media ".concat(f[2]," {").concat(f[1],"}"),f[2]=t):f[2]=t),r&&(f[4]?(f[1]="@supports (".concat(f[4],") {").concat(f[1],"}"),f[4]=r):f[4]="".concat(r)),n.push(f))}},n}},81:e=>{e.exports=function(e){return e[1]}},548:(e,n,t)=>{var i=t(379),r=t.n(i),o=t(795),a=t.n(o),s=t(569),l=t.n(s),c=t(565),f=t.n(c),d=t(216),u=t.n(d),h=t(589),m=t.n(h),g=t(424),p={};p.styleTagTransform=m(),p.setAttributes=f(),p.insert=l().bind(null,"head"),p.domAPI=a(),p.insertStyleElement=u(),r()(g.Z,p),g.Z&&g.Z.locals&&g.Z.locals},379:e=>{var n=[];function t(e){for(var t=-1,i=0;i<n.length;i++)if(n[i].identifier===e){t=i;break}return t}function i(e,i){for(var o={},a=[],s=0;s<e.length;s++){var l=e[s],c=i.base?l[0]+i.base:l[0],f=o[c]||0,d="".concat(c," ").concat(f);o[c]=f+1;var u=t(d),h={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==u)n[u].references++,n[u].updater(h);else{var m=r(h,i);i.byIndex=s,n.splice(s,0,{identifier:d,updater:m,references:1})}a.push(d)}return a}function r(e,n){var t=n.domAPI(n);return t.update(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap&&n.supports===e.supports&&n.layer===e.layer)return;t.update(e=n)}else t.remove()}}e.exports=function(e,r){var o=i(e=e||[],r=r||{});return function(e){e=e||[];for(var a=0;a<o.length;a++){var s=t(o[a]);n[s].references--}for(var l=i(e,r),c=0;c<o.length;c++){var f=t(o[c]);0===n[f].references&&(n[f].updater(),n.splice(f,1))}o=l}}},569:e=>{var n={};e.exports=function(e,t){var i=function(e){if(void 0===n[e]){var t=document.querySelector(e);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(e){t=null}n[e]=t}return n[e]}(e);if(!i)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");i.appendChild(t)}},216:e=>{e.exports=function(e){var n=document.createElement("style");return e.setAttributes(n,e.attributes),e.insert(n,e.options),n}},565:(e,n,t)=>{e.exports=function(e){var n=t.nc;n&&e.setAttribute("nonce",n)}},795:e=>{e.exports=function(e){var n=e.insertStyleElement(e);return{update:function(t){!function(e,n,t){var i="";t.supports&&(i+="@supports (".concat(t.supports,") {")),t.media&&(i+="@media ".concat(t.media," {"));var r=void 0!==t.layer;r&&(i+="@layer".concat(t.layer.length>0?" ".concat(t.layer):""," {")),i+=t.css,r&&(i+="}"),t.media&&(i+="}"),t.supports&&(i+="}");var o=t.sourceMap;o&&"undefined"!=typeof btoa&&(i+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o))))," */")),n.styleTagTransform(i,e,n.options)}(n,e,t)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(n)}}}},589:e=>{e.exports=function(e,n){if(n.styleSheet)n.styleSheet.cssText=e;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(e))}}},574:e=>{e.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\n#define MAX_LIGHTS 2\n#define MAX_SPHERES 4\n#define MAX_PLANES 6\n\n#define specular_exponent 128.0\n#define EPSILON 0.001\n#define PI 3.141593\n#define PI2 6.283185\n#define PHI 2.399963 // golden angle in radians\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602);\n\nfloat randomIncrement;\nuniform float randomseed;\n\nuniform int numLights;\nuniform vec3 lightPos[MAX_LIGHTS];\nuniform vec2 lightSize[MAX_LIGHTS];\nuniform vec3 lightBrightness[MAX_LIGHTS];\nuniform vec2 lightSpot[MAX_LIGHTS];\nuniform int shadowSamples;\nuniform float shadowDim;\nuniform vec2 attenuationFactor;\n\nuniform int numSpheres;\nuniform vec3 sphereCenters[MAX_SPHERES];\nuniform vec3 sphereColors[MAX_SPHERES];\nuniform vec3 reflectiveColors[MAX_SPHERES];\nuniform vec3 sphereSpecColors[MAX_SPHERES];\nuniform float sphereRoughness[MAX_SPHERES];\n\nuniform int numPlanes;\nuniform float planeOffsets[MAX_PLANES];\nuniform vec3 planeNormals[MAX_PLANES];\nuniform vec3 planeColors[MAX_PLANES];\nuniform float planeSpecular[MAX_PLANES];\nuniform float planeRoughness[MAX_PLANES];\n\nuniform int rayBounces;\nuniform vec3 ambientLight;\nuniform bool enableGI;\nuniform bool enableRefGI;\nuniform int indirectSamples;\nuniform bool enablePlaneBacksides;\nuniform bool enablePlaneMirrors;\nuniform bool enableTAA;\n\nuniform sampler2D u_texture;\n\nin vec3 origin;\nin vec3 ray;\nin vec2 texCoord;\n\nout vec4 fragColor;\n\n/* ==== HELPER FUNCTIONS ==== */\n// https://stackoverflow.com/a/10625698\nfloat random( vec2 p ) {\n    vec2 K1 = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    randomIncrement += 0.02; // increment, so that each access gets different value\n    return fract( cos( dot(p+randomIncrement,K1) ) * 12345.6789 );\n}\n\nfloat square(float x) { return x * x; }\n\n//https://github.com/NVIDIA/Q2RTX/blob/master/src/refresh/vkpt/shader/utils.glsl\nmat3 construct_ONB_frisvad(vec3 normal) {\n    mat3 ret;\n    ret[1] = normal;\n    if(normal.z < -0.999805696) {\n        ret[0] = vec3(0.0, -1.0, 0.0);\n        ret[2] = vec3(-1.0, 0.0, 0.0);\n    }\n    else {\n        float a = 1.0 / (1.0 + normal.z);\n        float b = -normal.x * normal.y * a;\n        ret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n        ret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n    }\n    return ret;\n}\n\nvec3 LessThan(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1.0 : 0.0,\n        (f.y < value) ? 1.0 : 0.0,\n        (f.z < value) ? 1.0 : 0.0);\n}\n/* =============== */\n\nbool intersectSphere(vec3 ray_origin, vec3 ray_direction, vec3 center, float radius, float tmin, inout float t_hit) {\n    vec3 vec_to_orig = center - ray_origin; \n\n    float t_closest = dot(vec_to_orig , ray_direction); // t at the closest to the sphere's center\n    if (t_closest < 0.0) // If negative, the ray and sphere are on other sides of the origin\n        return false; \n\n    float dist_to_center2 = dot(vec_to_orig, vec_to_orig) - t_closest * t_closest;\n    float radius_sqr = radius*radius;\n    if (dist_to_center2 > radius_sqr) // If the smallest distance^2 from the ray to center is larger that radius^2, the ray doesn't intersect\n        return false; \n\n    float dist_mid_to_surface = sqrt(radius_sqr - dist_to_center2); \n    float t_surface1 = t_closest - dist_mid_to_surface; // t values at surfaces on both sides\n    float t_surface2 = t_closest + dist_mid_to_surface;\n\n    float t = (t_surface1 < tmin) ? t_surface2 : t_surface1;\n    if (t < t_hit && t > tmin) {\n        t_hit = t;\n        return true;\n    }\n    return false;\n}\n\nbool intersectPlane(vec3 ray_origin, vec3 ray_direction, float offset, vec3 normal, vec3 center, vec2 size, float tmin, inout float t_hit) {\n    vec3 normal_offset = normal * offset;\n    float d = normal_offset.x + normal_offset.y + normal_offset.z;\n    float t = (d - dot(normal, ray_origin)) / dot(normal, ray_direction);\n    \n    if (t < t_hit && t > tmin) {\n        vec3 tmpPos = ray_origin + ray_direction * t;\n        if (size.x + size.y == 0.0 || (\n            tmpPos.x < center.x + size.x*0.5 &&\n            tmpPos.x > center.x - size.x*0.5 &&\n            tmpPos.z < center.z + size.y*0.5 &&\n            tmpPos.z > center.z - size.y*0.5)) {\n            t_hit = t;\n            return true;\n        }\n    }\n    return false;\n}\n\n// Intersects with all of the objects in the world and returns closest hit (note the use of \"out\" arguments)\nbool intersect(vec3 ray_origin,\n            vec3 ray_direction,\n            inout float t_hit,\n            float tmin,\n            out vec3 position,\n            out vec3 normal,\n            inout vec3 diffuseColor,\n            inout vec3 specularColor,\n            inout vec3 reflectiveColor,\n            inout float roughness,\n            inout bool intersectLight)\n{\n    int intersected = 0;\n    int idx = 0;\n    \n    // Intersect spheres\n    for (int i = 0; i < numSpheres; i++) {\n        if (intersectSphere(ray_origin, ray_direction, sphereCenters[i], 0.8, tmin, t_hit)) {\n            idx = i;\n            intersected = 1;\n        }\n    }\n\n    // Intersect planes\n    for (int i = 0; i < numPlanes; i++) {\n        vec3 planeNormal = planeNormals[i];\n        if (enablePlaneBacksides || dot(ray_direction, planeNormal) < 0.0) {\n            if (intersectPlane(ray_origin, ray_direction, planeOffsets[i], planeNormal, vec3(0,0,0), vec2(0,0), tmin, t_hit)) {\n                normal = planeNormal;\n                idx = i;\n                intersected = 2;\n            }\n        }\n    }\n\n    // Intersect lights to make them visible\n    if (intersectLight) {\n        intersectLight = false;\n        for (int i = 0; i < numLights; i++) {\n            vec3 center = lightPos[i];\n            vec2 size = lightSize[i];\n            bool tmp = false;\n            if (size.x > 0.0 && size.y > 0.0) // area light\n                tmp = intersectPlane(ray_origin, ray_direction, center.y, vec3(0.0,1.0,0.0), center, size, tmin, t_hit);\n            else // point light\n                tmp = intersectSphere(ray_origin, ray_direction, center, 0.1, tmin, t_hit);\n            if (tmp) {\n                idx = i;\n                intersected = 3;\n            }\n        }\n    }\n\n    position = ray_origin + ray_direction * t_hit;\n\n    // Make only one set of color lookups for each intersection\n    if (intersected == 1) { // Sphere\n        diffuseColor = sphereColors[idx];\n        specularColor = sphereSpecColors[idx];\n        reflectiveColor = reflectiveColors[idx];\n        roughness = sphereRoughness[idx];\n        normal = normalize(position - sphereCenters[idx]);\n        if (dot(normal, -ray_direction) < 0.0) // Backside shading: flip normal if ray and normal are on different sides\n            normal *= -1.0;\n    }\n    else if (intersected == 2) { // Plane\n        if (!enablePlaneMirrors) {\n            diffuseColor = planeColors[idx];\n            specularColor = planeSpecular[idx] * vec3(1.0, 1.0, 1.0);\n            reflectiveColor = vec3(0.0);\n            roughness = planeRoughness[idx];\n        } else {\n            diffuseColor = planeColors[idx]*0.01;\n            specularColor = vec3(0.0);\n            reflectiveColor = planeColors[idx];\n            roughness = 1.0;\n        }\n        if (dot(normal, -ray_direction) < 0.0)\n            normal *= -1.0;\n    }\n    else if (intersected == 3) { // Light\n        float spot_falloff = 1.0;\n        vec2 spot = lightSpot[idx];\n        if (spot.x > 0.0) {\n            float dot_to_light = dot(ray_direction, vec3(0.0, 1.0, 0.0));\n            spot_falloff = (dot_to_light > spot.x) ? pow(dot_to_light, spot.y) : 0.0;\n        }\n        diffuseColor = spot_falloff * lightBrightness[idx] * 0.2;\n        intersectLight = true;\n    }\n\n    return intersected != 0;\n}\n\n// Faster intersect function for shadows\nbool intersectShadowRay(vec3 ray_origin, vec3 ray_direction, inout float t_hit) {\n    for (int i = 0; i < numSpheres; i++)\n        if (intersectSphere(ray_origin, ray_direction, sphereCenters[i], 0.8, EPSILON, t_hit))\n            return true;\n    for (int i = 0; i < numPlanes; i++)\n        if (intersectPlane(ray_origin, ray_direction, planeOffsets[i], planeNormals[i], vec3(0.0), vec2(0.0), EPSILON, t_hit))\n            return true;\n    return false;\n}\n\nvoid getIncidentIntensity(float sample_i, vec3 P, vec3 lightPos, vec3 intensity, vec2 size, vec2 spot, bool isAreaLight, out float L_dist, out vec3 L, out vec3 incidentIntensity) {\n    if (isAreaLight) { // Get jittered position on the light plane\n        float inv_dim = 1.0 / shadowDim;\n        float cell_sizeX = size.x * inv_dim;\n        float cell_sizeY = size.y * inv_dim;\n        float posX = cell_sizeX * (mod(sample_i, shadowDim) + random(P.xy));\n        float posY = cell_sizeY * (floor(sample_i * inv_dim) + random(P.yx));\n        float x = lightPos.x - size.x*0.5 + posX;\n        float z = lightPos.z - size.y*0.5 + posY;\n        L = vec3(x, lightPos.y, z) - P;\n    } else { // point light\n        L = lightPos - P; \n    }\n\n    L_dist = length(L);\n    float attenuation = 1.0 / (attenuationFactor.x*square(L_dist) + attenuationFactor.y*L_dist);\n    L = normalize(L);\n\n    // Spotlight effect\n    // spot.x is the size of the spot and spot.y is the exponent to produce smooth falloff\n    float falloff = 1.0;\n    if (spot.x > 0.0) {\n        float dot_to_light = dot(L, vec3(0.0, 1.0, 0.0));\n        falloff = (dot_to_light > spot.x) ? pow(dot_to_light, spot.y) : 0.0;\n    }\n\n    incidentIntensity = intensity * attenuation * falloff;\n}\n\n/** \n* Phong shading \n*   - does not take into account if light and normal are on the same side or not\n*\n*   V:    View vector towards surface\n*   N:    Normal of surface\n*   L:    Vector towards light from surface\n*/\nvec3 shadePhong(vec3 V, vec3 N, vec3 L, vec3 diffuseColor, vec3 specularColor) {\n    vec3 diffuse = diffuseColor * dot(N, L); // Diffuse brightness depends on the angle between light and normal\n        \n    vec3 R = reflect(-L, N); // Reflection vector pointing away from object\n    float reflection_intensity = pow(max(0.0, dot(R, -V)), specular_exponent); // Specular intensity depends on how closely the reflection vector points to the camera\n    vec3 specular = specularColor * reflection_intensity;\n\n    return diffuse + specular;\n}\n\n// Calculates and returns specular and diffuse illumination from all lights on a given point\nvec3 directIllumination(vec3 P, vec3 V, vec3 N, vec3 diffuseColor, vec3 specularColor, bool useSampling) {\n    vec3 illuminationColor;\n\n    for (int i = 0; i < numLights; i++) {\n        vec3 lightPos = lightPos[i];\n        vec3 lightBrightness = lightBrightness[i];\n        vec2 lightSize = lightSize[i];\n        vec2 lightSpot = lightSpot[i];\n        vec3 light_sum, incidentIntensity, L;\n        float L_dist;\n        bool isAreaLight = useSampling && lightSize.x > 0.0 && lightSize.y > 0.0;\n        int testSamples = isAreaLight ? 5 : 1; // use one sample if calculating pointlights\n        int areaShadowSamples = 0;\n        bool inLight, inShade = false;\n\n        // Get 5 test points to the light (4 corners, 1 center)\n        for (int k = 0; k < testSamples; k++) {\n            if (inLight && inShade) break; // best-case-scenaraio: stop after two test samples\n\n            vec3 testPos = lightPos;\n            if (k == 1) { // up left\n                testPos.x -= lightSize.x*0.5;\n                testPos.z -= lightSize.y*0.5;\n            }\n            else if (k == 2) { // bottom right\n                testPos.x += lightSize.x*0.5;\n                testPos.z += lightSize.y*0.5;\n            }\n            else if (k == 3) { // up right\n                testPos.x += lightSize.x*0.5;\n                testPos.z -= lightSize.y*0.5;\n            }\n            else if (k == 4) { // bottom left\n                testPos.x -= lightSize.x*0.5;\n                testPos.z += lightSize.y*0.5;\n            }\n\n            getIncidentIntensity(float(k), P, testPos, lightBrightness, lightSize, lightSpot, false, L_dist, L, incidentIntensity);\n\n            if (dot(N, L) > 0.0 && incidentIntensity.r + incidentIntensity.g + incidentIntensity.b > 0.01) { // If no light falls to this point, do not check for shadows\n                float t_shadowHit = L_dist;\n                intersectShadowRay(P, L, t_shadowHit);\n                if (abs(t_shadowHit - L_dist) < EPSILON) {\n                    light_sum += incidentIntensity * shadePhong(V, N, L, diffuseColor, specularColor);\n                    inLight = true;\n                } else {\n                    inShade = true; // in shadow of object\n                }\n            } else {\n                inShade = true;\n            }\n\n            areaShadowSamples++;\n        }\n\n        // If after 5 test samples there is atleast one ray that doesn't reach light and one that reaches the light, the point should have more accurate shading (shadow edges)\n        if (isAreaLight && inLight && inShade) {\n            areaShadowSamples = shadowSamples;\n            light_sum = vec3(0.0); // Start the sampling over, because keeping the results of regular sampling would produce banding\n            for (int k = 0; k < areaShadowSamples; k++) {\n                vec3 incidentIntensity, L;\n                float L_dist;\n                getIncidentIntensity(float(k), P, lightPos, lightBrightness, lightSize, lightSpot, true, L_dist, L, incidentIntensity);\n                \n                float t_shadowHit = L_dist;\n                if (!intersectShadowRay(P, L, t_shadowHit)) {\n                    light_sum += incidentIntensity * shadePhong(V, N, L, diffuseColor, specularColor);\n                }\n            }\n        }\n\n        illuminationColor += light_sum / float(areaShadowSamples);\n    }\n    return illuminationColor;\n}\n\n// Faster direct illumination calculation with one sample\n// includes phong shading (without specularity)\nvec3 directIlluminationFast(vec3 P, vec3 N, vec3 diffuseColor) {\n    vec3 illuminationColor;\n\n    // Add direct lighting from each light\n    // stops the calculations asap using many conditionals\n    // nested if's seem to have better performance than continues, but break's would give best perf (with one light)\n    for (int i = 0; i < numLights; i++) {\n        vec3 L = lightPos[i] - P;\n        float L_dist = length(L);\n        L = normalize(L);\n        \n        vec2 lightSpot = lightSpot[i];\n        float spotAttenuation = 1.0;\n        if (lightSpot.x > 0.0) {\n            float dot_to_light = dot(L, vec3(0.0, 1.0, 0.0));\n            spotAttenuation = (dot_to_light > lightSpot.x) ? pow(dot_to_light, lightSpot.y) : 0.0;\n        }\n            \n        if (spotAttenuation > 0.0) { // Skip if the point is outside of spotlight\n            vec3 lightBrightness = lightBrightness[i];\n            float distAttenuation = 1.0 / (attenuationFactor.x*square(L_dist) + attenuationFactor.y*L_dist);\n                \n            if (distAttenuation > 0.004) { // Skip if the brightness of light at the point is too small\n                float NoL = dot(N, L);\n\n                // Skip if normal and vector to light point at different directions\n                if (NoL > 0.0) {\n                    \n                    // Skip if the light ray intersected with an object before reaching the point\n                    float shadowHitDist = L_dist;\n                    if (!intersectShadowRay(P, L, shadowHitDist)) {\n                        vec3 illuminationIntensity = lightBrightness * distAttenuation * spotAttenuation;\n                        illuminationColor += diffuseColor * illuminationIntensity * NoL;\n                    }\n                }\n            }\n        }\n    }\n    return illuminationColor;\n}\n\nfloat G1_Smith(float alpha_sqr, float NdotL) {\n    return 2.0 * NdotL / (NdotL + sqrt(alpha_sqr + (1.0 - alpha_sqr) * square(NdotL)));\n}\n\n// Algorithm: http://jcgt.org/published/0007/04/01/\n// & https://github.com/NVIDIA/Q2RTX/issues/40\nvec3 importanceSampleGGX_VNDF(vec2 u, float alpha, vec3 V, mat3 basis) {\n    vec3 Ve = -vec3(dot(V, basis[0]), dot(V, basis[2]), dot(V, basis[1]));\n    vec3 Vh = normalize(vec3(alpha * Ve.x, alpha * Ve.y, Ve.z));\n    \n    float lensq = square(Vh.x) + square(Vh.y);\n    vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1.0, 0.0, 0.0);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(u.x);\n    float phi = 2.0 * PI * u.y;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - square(t1)) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - square(t1) - square(t2))) * Vh;\n\n    // Tangent space H\n    vec3 Ne = vec3(alpha * Nh.x, max(0.0, Nh.z), alpha * Nh.y);\n\n    // World space H\n    return normalize(basis * Ne);\n}\n\n/** \n* Calculates indirect illumination with Monte Carlo sampling for metallic surfaces\n*   - Uses VNDF importance sampling to model GGX BRDF\n*   - Uses only one bounce due to exponential performance hit\n* \n* Arguments:\n*   P           : the point at which lighting is calculated\n*   V           : direction of ray (towards P)\n*   N           : surface normal at P\n*   diffuse     : diffuse color of surface at P\n*   roughness   : [0,1] non squared roughness of surface at P\n*\n* Returns:\n*   vec3        : indirect light at P\n*/\nvec3 indirectIlluminationGGX(vec3 P, vec3 V, vec3 N, vec3 diffuse, float roughness) {\n    vec3 indirect_sampling_sum;\n    mat3 basis = construct_ONB_frisvad(N);\n    float VNDF_alpha = square(roughness);\n    float G1_alpha = square(square(max(roughness, 0.02)));\n\n    for (int i = 0; i < indirectSamples; i++) {\n\t\tvec3 H = importanceSampleGGX_VNDF(vec2(random(P.xz), random(P.xy)), VNDF_alpha, V, basis);\n\t\tvec3 R = reflect(V, H);\n        float NoR = max(0.0, dot(N, R));\n        float G1_NoR = G1_Smith(G1_alpha, NoR);\n        R = normalize(R);\n\n        float hitDist = 20.0;\n        vec3 P2, N2, diffuse2, specular2, reflective2;\n        float roughness2;\n        bool intersectLight = true;\n        \n        // Intersect the bounced ray\n        // Add lighting from the secondary hit point\n        intersect(P, R, hitDist, 0.01, P2, N2, diffuse2, specular2, reflective2, roughness2, intersectLight);\n        indirect_sampling_sum += intersectLight ? diffuse2 : G1_NoR * directIlluminationFast(P2, N2, diffuse2+reflective2);\n    }\n    // Return the scaled indirect light\n    return ((indirect_sampling_sum / float(indirectSamples)) * diffuse);\n}\n\n// Get semi-random point in unit sphere using fibonacci spiral (https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere)\nvec3 fibonacciSphereDir(vec2 rand, float sampleIdx, float inv_samples, float jitter_scale) {\n    float y = (1.0 - (sampleIdx*inv_samples) * 2.0) + (random(rand)*5.0-2.5)*jitter_scale; // y goes from 1 to -1 (with added jitter)\n    float radius = sqrt(1.0 - y*y); // radius at y\n    float theta = (PHI * sampleIdx) + (random(rand)*10.0-5.0)*jitter_scale; // golden angle increment in spiral (with added jitter)\n    return vec3(cos(theta)*radius, y, sin(theta)*radius);\n}\n\n// Same as indirectGGX, but optimized for fully diffuse surfaces\nvec3 indirectIlluminationLambert(vec3 P, vec3 V, vec3 N, vec3 diffuseColor) {\n    vec3 indirect_sampling_sum;\n    vec3 mirrorDir = reflect(V, N);\n    float inv_samples = 1.0/float(indirectSamples-1);\n    float jitter_scale = pow(float(indirectSamples), -0.5);\n\n    for (int i = 0; i < indirectSamples; i++) {\n        // Direction is calculated with Lambert's cosine law (https://raytracing.github.io/books/RayTracingInOneWeekend.html#diffusematerials)\n        vec3 diffuseDir = normalize(N + fibonacciSphereDir(P.xy, float(i), inv_samples, jitter_scale));\n        vec3 R = normalize(mix(mirrorDir, diffuseDir, 1.0));\n\n        float hitDist = 10.0;\n        vec3 P2, N2, diffuse2, specular2, reflective2;\n        float roughness2;\n        bool intersectLight = false;\n\n        intersect(P, R, hitDist, 0.01, P2, N2, diffuse2, specular2, reflective2, roughness2, intersectLight);\n        indirect_sampling_sum += directIlluminationFast(P2, N2, diffuse2+reflective2);\n    }\n    return ((indirect_sampling_sum / float(indirectSamples)) * diffuseColor);\n}\n\n// Calculates and returns mirror reflections on a given point\nvec3 reflectionIllumination(vec3 P, vec3 V, vec3 N, vec3 reflectiveColor) {\n    vec3 reflectionSum;\n    for (int i = 0; i < rayBounces; i++) {\n        if (reflectiveColor.x + reflectiveColor.y + reflectiveColor.z == 0.0) break; // Stop if we reach max number of bounces or hit material that is not reflective\n\n        V = reflect(V, N); // Get the direction of the reflected ray\n        \n        float hitDist = 20.0;\n        vec3 P2, diffuse2, specular2, reflective2;\n        float roughness2;\n        bool intersectLight = true;\n\n        // Trace the reflected ray and add the result to pixel\n        intersect(P, V, hitDist, 0.01, P2, N, diffuse2, specular2, reflective2, roughness2, intersectLight);\n        vec3 mirror_sample_color = intersectLight ? diffuse2 : directIllumination(P2, V, N, diffuse2, specular2, false);\n        \n        if (enableRefGI) // Add indirect illumination to reflection\n            mirror_sample_color += indirectIlluminationLambert(P2, V, N, diffuse2);\n        else\n            mirror_sample_color += ambientLight * diffuse2;\n\n        P = P2;\n        reflectionSum += mirror_sample_color * reflectiveColor;\n        reflectiveColor = reflective2 * reflectiveColor;  // Successive ray colors are affected by each reflective surface's color\n    }\n    return reflectionSum;\n}\n          \nvec3 LinearToSRGB(vec3 rgb) {     \n    return mix(\n        pow(rgb, vec3(1.0 / 2.2)) * 1.055 - 0.055,\n        rgb * 12.92,\n        LessThan(rgb, 0.0031308)\n    );\n}\n\nvec3 ACESFilm(vec3 x) {\n    x = ACESInputMat * x;\n    vec3 a = x * (x + 0.0245786) - 0.000090537;\n    vec3 b = x * (0.983729 * x + 0.4329510) + 0.238081;\n    x = a / b;\n    x = ACESOutputMat * x;\n    return clamp(x, 0.0, 1.0);\n}\n\n// Simple color averaging from previous frames\nvec4 averageTAA(vec3 pixelColor) {\n    if (enableTAA)\n        return 0.1 * min(vec4(pixelColor, 1), 1.0) + 0.9 * texture(u_texture, texCoord);\n    else\n        return vec4(pixelColor, 1);\n}\n\nvoid main() {\n    vec3 ray_dir = normalize(ray);\n    float hit_dist = length(ray); // The far clipping distance\n    vec3 pixelColor, diffuseColor, specularColor, reflectiveColor, normal, point;\n    float roughness;\n    bool intersectLight = true;\n    randomIncrement = randomseed;\n\n    // intersect the ray with objects (tmin is 0, because vertex shader places the origin of the ray in near clipping distance)\n    intersect(origin, ray_dir, hit_dist, 0.0, point, normal, diffuseColor, specularColor, reflectiveColor, roughness, intersectLight);\n\n    // If the ray hit a light, return its color because it doesn't have any other properties than surface color\n    if (intersectLight) {\n        fragColor = averageTAA(diffuseColor);\n        return;\n    }\n\n    // Ambient light\n    if (!enableGI)\n        pixelColor += ambientLight * diffuseColor;\n\n    // ==== DIRECT ILLUMINATION ====\n    // For GGX surfaces direct illumination may or may not be added; currently scale the amount by roughness\n    // See more about conductors and dielectrics in: https://google.github.io/filament/Filament.html#figure_dielectricconductor\n    pixelColor += roughness * directIllumination(point, ray_dir, normal, diffuseColor, specularColor, true);\n\n    // ==== INDIRECT ILLUMINATION ====\n    if (enableGI && diffuseColor.r > 0.0 && diffuseColor.g > 0.0 && diffuseColor.b > 0.0) {\n        if (roughness < 1.0) // GGX is much slower, so use it only when needed\n            pixelColor += indirectIlluminationGGX(point, ray_dir, normal, diffuseColor, roughness);\n        else\n            pixelColor += indirectIlluminationLambert(point, ray_dir, normal, diffuseColor);\n    }\n        \n    // ==== MIRROR REFLECTION ====\n    if (rayBounces > 0 && length(reflectiveColor) > 0.0)\n        pixelColor += reflectionIllumination(point, ray_dir, normal, reflectiveColor);\n\n    // ==== POST FX & OUTPUT ====\n    // ACES tonemapping (source: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl)\n    pixelColor = ACESFilm(pixelColor);\n    pixelColor = LinearToSRGB(pixelColor);\n    \n    fragColor = averageTAA(pixelColor);\n}"},675:e=>{e.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nuniform mat4 invprojview;\nuniform float near;\nuniform float far;\n\nout vec3 origin;\nout vec3 ray;\nout vec2 texCoord;\n\nvoid main() {\n    // https://rauwendaal.net/2014/06/14/rendering-a-screen-covering-triangle-in-opengl/\n    float x = -1.0 + float((gl_VertexID & 1) << 2);\n    float y = -1.0 + float((gl_VertexID & 2) << 1);\n    texCoord.x = (x+1.0)*0.5;\n    texCoord.y = (y+1.0)*0.5;\n    gl_Position = vec4(x, y, 0, 1);\n                \n    // https://stackoverflow.com/a/52764898\n    origin = (invprojview * vec4(x, y, -1.0, 1.0) * near).xyz;\n    ray = (invprojview * vec4(vec2(x,y) * (far - near), far + near, far - near)).xyz;\n}"}},n={};function t(i){var r=n[i];if(void 0!==r)return r.exports;var o=n[i]={id:i,exports:{}};return e[i](o,o.exports,t),o.exports}t.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return t.d(n,{a:n}),n},t.d=(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),t(84),t(548)})();