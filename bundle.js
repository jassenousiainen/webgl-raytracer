(()=>{"use strict";var e,n,t,r,i,o,a,l,s,c,u,f,d,m,h={424:(e,n,t)=>{t.d(n,{Z:()=>l});var r=t(81),i=t.n(r),o=t(645),a=t.n(o)()(i());a.push([e.id,"/* ----- COLORS ----- */\n:root {\n    --blue: #007bff;\n    /*--blue: #2e5bff;*/\n    --darkblue: #1374dc;\n    --blue-neon: #0dffff;\n    --teal: #11cdef;\n    --lightgreen: #00d774;\n    --orange: #fd7e14;\n    --darkorange: #e07217;\n    --gray1: #f4f5f7;\n    --gray2: #e2e6ea;\n    --gray3: #6c757d;\n    --gray4: #343a40;\n    --green: #28a745;\n    --green-dark: #1c8935;\n    --red: #dc3545;\n    --red-dark: #c42e3d;\n    --red-bright: #ff3355;\n    --red-light: #ff6384;\n    --purple-light: #5e72e4;\n    --purple: #6f42c1;\n    --purple-dark: rgb(112, 48, 160);\n}\n/*------------------------*/\n\nhtml {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n}\n\nbody {\n    margin: 0;\n    padding: 0;\n    background-color: rgb(0, 0, 0);\n    overflow: hidden;\n}\n/*\ncanvas {\n    width: 100%;\n    height: 100%;\n}\n*/\n.controls {\n    position: absolute;\n    top: 4vh;\n    right: 1em;\n    width: 250px;\n    padding: 0 0.2em 1em 1em;\n    background-color: rgb(255 255 255 / 60%);\n    border-radius: 15px;\n    max-height: 91vh;\n    overflow-y: scroll;\n    overflow-x: hidden;\n}\n\n.controls::-webkit-scrollbar-track {\n    /*-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);*/\n \t/*border-radius: 10px;*/\n}\n.controls::-webkit-scrollbar {\n \twidth: 1em;\n}\n.controls::-webkit-scrollbar-thumb {\n    background-color: var(--blue);\n    border: 5px solid transparent;\n    border-radius: 15px;\n    background-clip: padding-box;\n}\n.controls::-webkit-scrollbar-thumb:hover {\n\tbackground-color: var(--darkblue);\n}\n\n.controls .section {\n    border-bottom: solid 1px rgb(255 255 255 / 60%);\n    margin: 1em 0 0 0;\n    padding: 0 0 1em;\n}\n\n.controls h3 {\n    padding: 0;\n    margin: 0 0 0.5em 0;\n    color: #005aff;\n    font-weight: 600;\n}\n\n.controls output {\n    color: #005aff;\n}\n\n.controls .deg-sign {\n    color: #005aff;\n}\n\n.controls .slider_container {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\ntable.sliders {\n    width: 100%;\n}\n\n.sliders input {\n    width: 100%;\n}\n\n#fps-container {\n    position: absolute;\n    top: 1vh;\n    left: 1em;\n    color: white;\n}\n\n#ui_switch {\n    position: absolute;\n    top: 1vh;\n    right: 1em;\n    color: white;\n}\n\n/* ----- Toggle switch ----- */\n/* The switch - the box around the slider */\n.switch {\n    position: relative;\n  }\n  /* Hide default HTML checkbox */\n  .switch input {\n    position: absolute;\n    opacity: 0;\n    width: 0;\n    height: 0;\n  }\n  /* The slider */\n  .slider {\n    border-radius: 10px;\n    position: relative;\n    display: inline-block;\n    cursor: pointer;\n    vertical-align: middle;\n    height: 15px;\n    width: 34px;\n    background-color: var(--gray2);\n    -webkit-transition: 0.4s;\n    transition: 0.4s;\n  }\n  .slider:before {\n    position: absolute;\n    content: \"\";\n    height: 11px;\n    width: 11px;\n    left: 3px;\n    bottom: 2px;\n    background-color: white;\n    -webkit-transition: 0.4s;\n    transition: 0.4s;\n    box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.21);\n    border-radius: 5px;\n  }\n  input:checked + .slider {\n    background-color: var(--blue);\n  }\n  input:checked + .slider.del {\n    background-color: var(--red-bright);\n  }\n  input:checked + .slider:before {\n    transform: translateX(17px);\n  }\n  /* ----------------------- */",""]);const l=a},645:e=>{e.exports=function(e){var n=[];return n.toString=function(){return this.map((function(n){var t="",r=void 0!==n[5];return n[4]&&(t+="@supports (".concat(n[4],") {")),n[2]&&(t+="@media ".concat(n[2]," {")),r&&(t+="@layer".concat(n[5].length>0?" ".concat(n[5]):""," {")),t+=e(n),r&&(t+="}"),n[2]&&(t+="}"),n[4]&&(t+="}"),t})).join("")},n.i=function(e,t,r,i,o){"string"==typeof e&&(e=[[null,e,void 0]]);var a={};if(r)for(var l=0;l<this.length;l++){var s=this[l][0];null!=s&&(a[s]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&a[u[0]]||(void 0!==o&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=o),t&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=t):u[2]=t),i&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=i):u[4]="".concat(i)),n.push(u))}},n}},81:e=>{e.exports=function(e){return e[1]}},379:e=>{var n=[];function t(e){for(var t=-1,r=0;r<n.length;r++)if(n[r].identifier===e){t=r;break}return t}function r(e,r){for(var o={},a=[],l=0;l<e.length;l++){var s=e[l],c=r.base?s[0]+r.base:s[0],u=o[c]||0,f="".concat(c," ").concat(u);o[c]=u+1;var d=t(f),m={css:s[1],media:s[2],sourceMap:s[3],supports:s[4],layer:s[5]};if(-1!==d)n[d].references++,n[d].updater(m);else{var h=i(m,r);r.byIndex=l,n.splice(l,0,{identifier:f,updater:h,references:1})}a.push(f)}return a}function i(e,n){var t=n.domAPI(n);return t.update(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap&&n.supports===e.supports&&n.layer===e.layer)return;t.update(e=n)}else t.remove()}}e.exports=function(e,i){var o=r(e=e||[],i=i||{});return function(e){e=e||[];for(var a=0;a<o.length;a++){var l=t(o[a]);n[l].references--}for(var s=r(e,i),c=0;c<o.length;c++){var u=t(o[c]);0===n[u].references&&(n[u].updater(),n.splice(u,1))}o=s}}},569:e=>{var n={};e.exports=function(e,t){var r=function(e){if(void 0===n[e]){var t=document.querySelector(e);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(e){t=null}n[e]=t}return n[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(t)}},216:e=>{e.exports=function(e){var n=document.createElement("style");return e.setAttributes(n,e.attributes),e.insert(n,e.options),n}},565:(e,n,t)=>{e.exports=function(e){var n=t.nc;n&&e.setAttribute("nonce",n)}},795:e=>{e.exports=function(e){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var n=e.insertStyleElement(e);return{update:function(t){!function(e,n,t){var r="";t.supports&&(r+="@supports (".concat(t.supports,") {")),t.media&&(r+="@media ".concat(t.media," {"));var i=void 0!==t.layer;i&&(r+="@layer".concat(t.layer.length>0?" ".concat(t.layer):""," {")),r+=t.css,i&&(r+="}"),t.media&&(r+="}"),t.supports&&(r+="}");var o=t.sourceMap;o&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o))))," */")),n.styleTagTransform(r,e,n.options)}(n,e,t)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(n)}}}},589:e=>{e.exports=function(e,n){if(n.styleSheet)n.styleSheet.cssText=e;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(e))}}}},g={};function p(e){var n=g[e];if(void 0!==n)return n.exports;var t=g[e]={id:e,exports:{}};return h[e](t,t.exports,p),t.exports}p.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return p.d(n,{a:n}),n},p.d=(e,n)=>{for(var t in n)p.o(n,t)&&!p.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},p.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),p.nc=void 0,(()=>{var e="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var n=Math.PI/180;function t(){var n=new e(16);return e!=Float32Array&&(n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0),n[0]=1,n[5]=1,n[10]=1,n[15]=1,n}function r(e,n){var t=n[0],r=n[1],i=n[2],o=n[3],a=n[4],l=n[5],s=n[6],c=n[7],u=n[8],f=n[9],d=n[10],m=n[11],h=n[12],g=n[13],p=n[14],v=n[15],_=t*l-r*a,b=t*s-i*a,y=t*c-o*a,x=r*s-i*l,L=r*c-o*l,S=i*c-o*s,E=u*g-f*h,C=u*p-d*h,T=u*v-m*h,N=f*p-d*g,P=f*v-m*g,A=d*v-m*p,I=_*A-b*P+y*N+x*T-L*C+S*E;return I?(I=1/I,e[0]=(l*A-s*P+c*N)*I,e[1]=(i*P-r*A-o*N)*I,e[2]=(g*S-p*L+v*x)*I,e[3]=(d*L-f*S-m*x)*I,e[4]=(s*T-a*A-c*C)*I,e[5]=(t*A-i*T+o*C)*I,e[6]=(p*y-h*S-v*b)*I,e[7]=(u*S-d*y+m*b)*I,e[8]=(a*P-l*T+c*E)*I,e[9]=(r*T-t*P-o*E)*I,e[10]=(h*L-g*y+v*_)*I,e[11]=(f*y-u*L-m*_)*I,e[12]=(l*C-a*N-s*E)*I,e[13]=(t*N-r*C+i*E)*I,e[14]=(g*b-h*x-p*_)*I,e[15]=(u*x-f*b+d*_)*I,e):null}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var i=function(e,n,t,r,i){var o,a=1/Math.tan(n/2);return e[0]=a/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(o=1/(r-i),e[10]=(i+r)*o,e[14]=2*i*r*o):(e[10]=-1,e[14]=-2*r),e},o=function(e,n,t){var r=n[0],i=n[1],o=n[2],a=n[3],l=n[4],s=n[5],c=n[6],u=n[7],f=n[8],d=n[9],m=n[10],h=n[11],g=n[12],p=n[13],v=n[14],_=n[15],b=t[0],y=t[1],x=t[2],L=t[3];return e[0]=b*r+y*l+x*f+L*g,e[1]=b*i+y*s+x*d+L*p,e[2]=b*o+y*c+x*m+L*v,e[3]=b*a+y*u+x*h+L*_,b=t[4],y=t[5],x=t[6],L=t[7],e[4]=b*r+y*l+x*f+L*g,e[5]=b*i+y*s+x*d+L*p,e[6]=b*o+y*c+x*m+L*v,e[7]=b*a+y*u+x*h+L*_,b=t[8],y=t[9],x=t[10],L=t[11],e[8]=b*r+y*l+x*f+L*g,e[9]=b*i+y*s+x*d+L*p,e[10]=b*o+y*c+x*m+L*v,e[11]=b*a+y*u+x*h+L*_,b=t[12],y=t[13],x=t[14],L=t[15],e[12]=b*r+y*l+x*f+L*g,e[13]=b*i+y*s+x*d+L*p,e[14]=b*o+y*c+x*m+L*v,e[15]=b*a+y*u+x*h+L*_,e};function a(e,n,t){var r=e.createShader(n);if(e.shaderSource(r,t),e.compileShader(r),e.getShaderParameter(r,e.COMPILE_STATUS))return r;console.log(e.getShaderInfoLog(r)),e.deleteShader(r)}function l(e){var n=e.createTexture();return e.bindTexture(e.TEXTURE_2D,n),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),n}function s(e,n,t){e.canvas.width=n,e.canvas.height=t,e.viewport(0,0,e.canvas.width,e.canvas.height)}const c=JSON.parse('{"nS":{"x":0,"y":0,"z":16,"fx":0,"tW":-0.01,"Bp":0.7,"On":0.1,"NC":50},"H":[{"x":0,"y":3.99,"z":0,"r":1,"g":1,"b":1,"sizeX":0.5,"sizeY":0.5,"brightness":3000,"spotSize":3.15,"spotIntensity":1.5,"rotate":false,"enabled":true},{"x":-3,"y":2.5,"z":0,"r":1,"g":1,"b":1,"sizeX":0.15,"sizeY":0.15,"brightness":20000,"spotSize":1.15,"spotIntensity":0,"rotate":true,"enabled":false}],"vi":[{"x":1.25,"y":-1.5,"z":-1.5,"r":0.9,"g":0.5,"b":0.9,"rr":0,"rg":0,"rb":0,"sr":1,"sg":1,"sb":1,"roughness":1},{"x":2.5,"y":-3.2,"z":-1.5,"r":0,"g":0,"b":0,"rr":1,"rg":1,"rb":1,"sr":1,"sg":1,"sb":1,"roughness":1},{"x":0,"y":-3.2,"z":-1.5,"r":0.9,"g":0.1,"b":0.1,"rr":0,"rg":0,"rb":0,"sr":0,"sg":0,"sb":0,"roughness":0.35},{"x":-2.5,"y":-3.2,"z":-1.5,"r":0.1,"g":0.9,"b":0.9,"rr":0,"rg":0,"rb":0,"sr":0,"sg":0,"sb":0,"roughness":0.5}],"Rm":[{"x":0,"y":1,"z":0,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":-4,"enabled":true,"desc":"floor"},{"x":0,"y":-1,"z":0,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":4,"enabled":true,"desc":"ceiling"},{"x":-1,"y":0,"z":0,"r":1,"g":0.1,"b":0.1,"specular":0,"roughness":1,"offset":4,"enabled":true,"desc":"right wall"},{"x":1,"y":0,"z":0,"r":0.1,"g":1,"b":0.1,"specular":0,"roughness":1,"offset":-4,"enabled":true,"desc":"left wall"},{"x":0,"y":0,"z":1,"r":0.9,"g":0.9,"b":0.5,"specular":0,"roughness":0.25,"offset":-4,"enabled":true,"desc":"back wall"},{"x":0,"y":0,"z":-1,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":4,"enabled":false,"desc":"front wall"}]}');var u=36,f=[];function d(e,n){var t=1,r=0,i=e;do{r+=(t/=n)*(i%n),i=Math.floor(i/n)}while(i>0);return r}for(var m=0;m<u;m++)f.push([d(m+1,2),d(m+1,3)]);var h=document.getElementById("fps"),g=!0,p=!0,v=!1,_=!1,b=!1,y=!1,x=!1,L=!1,S=0,E=0,C=1,T=performance.now(),N=0,P=1,A=0,I=document.querySelector("#canvas"),R=I.getContext("webgl2",{powerPreference:"high-performance",antialias:!1,alpha:!0,stencil:!1,depth:!1,desynchronized:!1,preserveDrawingBuffer:!1});R.getExtension("EXT_color_buffer_float")||console.log("Cannot render to floating point textures!");var w=function(e,n,t){console.log("COMPILING SHADERS");var r=a(e,e.VERTEX_SHADER,"#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nuniform mat4 invprojview;\nuniform float near;\nuniform float far;\n\nout vec3 origin;\nout vec3 ray;\nout vec2 texCoord;\n\nvoid main() {\n    // https://rauwendaal.net/2014/06/14/rendering-a-screen-covering-triangle-in-opengl/\n    float x = -1.0 + float((gl_VertexID & 1) << 2);\n    float y = -1.0 + float((gl_VertexID & 2) << 1);\n    texCoord.x = (x+1.0)*0.5;\n    texCoord.y = (y+1.0)*0.5;\n    gl_Position = vec4(x, y, 0, 1);\n                \n    // https://stackoverflow.com/a/52764898\n    origin = (invprojview * vec4(x, y, -1.0, 1.0) * near).xyz;\n    ray = (invprojview * vec4(vec2(x,y) * (far - near), far + near, far - near)).xyz;\n}"),i=a(e,e.FRAGMENT_SHADER,"#version 300 es\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\n#define MAX_LIGHTS 2\n#define MAX_SPHERES 4\n#define MAX_PLANES 6\n\n#define specular_exponent 128.0\n#define EPSILON 0.001\n#define PI 3.141593\n#define PI_RCP 0.318309886\n#define PI2 6.283185\n#define PHI 2.399963 // golden angle in radians\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602);\n\nfloat randomIncrement;\n\nuniform bool u_runTAA;\nuniform bool u_enableGI;\nuniform bool u_enableRefGI;\nuniform bool u_enableTonemapping;\nuniform bool u_enableGammaCorrection;\nuniform bool u_enablePlaneBacksides;\nuniform bool u_enablePlaneMirrors;\n\nuniform float u_randomseed;\nuniform float u_taaBlendFactor;\n\nuniform int u_directSamples;\nuniform float u_directSamplesSqrt;\nuniform int u_indirectSamples;\nuniform float u_rcp_indirectSamples;\nuniform int u_reflectionBounces;\n\nuniform int numLights;\nuniform vec3 lightPos[MAX_LIGHTS];\nuniform vec2 lightSize[MAX_LIGHTS];\nuniform vec3 u_lightEmission[MAX_LIGHTS];\nuniform vec2 lightSpot[MAX_LIGHTS];\n\nuniform int numSpheres;\nuniform vec3 sphereCenters[MAX_SPHERES];\nuniform vec3 sphereColors[MAX_SPHERES];\nuniform vec3 reflectiveColors[MAX_SPHERES];\nuniform vec3 sphereSpecColors[MAX_SPHERES];\nuniform float sphereRoughness[MAX_SPHERES];\n\nuniform int numPlanes;\nuniform float planeOffsets[MAX_PLANES];\nuniform vec3 planeNormals[MAX_PLANES];\nuniform vec3 planeColors[MAX_PLANES];\nuniform float planeSpecular[MAX_PLANES];\nuniform float planeRoughness[MAX_PLANES];\n\nuniform vec3 ambientLight;\n\nuniform sampler2D u_accumTexture;\n\nin vec3 origin;\nin vec3 ray;\nin vec2 texCoord;\n\nlayout (location = 0) out vec4 out_finalColor;\nlayout (location = 1) out vec4 out_accumulateColor;\n\n/* ==== HELPER FUNCTIONS ==== */\n// https://stackoverflow.com/a/10625698\nfloat random( vec2 p ) {\n    vec2 K1 = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    randomIncrement += 0.02; // increment, so that each access gets different value\n    return fract( cos( dot(p+randomIncrement,K1) ) * 12345.6789 );\n}\n\nfloat square(float x) { return x * x; }\n\n//https://github.com/NVIDIA/Q2RTX/blob/master/src/refresh/vkpt/shader/utils.glsl\nmat3 construct_ONB_frisvad(vec3 normal) {\n    mat3 ret;\n    ret[1] = normal;\n    if(normal.z < -0.999805696) {\n        ret[0] = vec3(0.0, -1.0, 0.0);\n        ret[2] = vec3(-1.0, 0.0, 0.0);\n    }\n    else {\n        float a = 1.0 / (1.0 + normal.z);\n        float b = -normal.x * normal.y * a;\n        ret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n        ret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n    }\n    return ret;\n}\n\nvec3 LessThan(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1.0 : 0.0,\n        (f.y < value) ? 1.0 : 0.0,\n        (f.z < value) ? 1.0 : 0.0);\n}\n/* =============== */\n\nbool intersectSphere(vec3 ray_origin, vec3 ray_direction, vec3 center, float radius, float tmin, inout float t_hit) {\n    vec3 vec_to_orig = center - ray_origin; \n\n    float t_closest = dot(vec_to_orig , ray_direction); // t at the closest to the sphere's center\n    if (t_closest < 0.0) // If negative, the ray and sphere are on other sides of the origin\n        return false; \n\n    float dist_to_center2 = dot(vec_to_orig, vec_to_orig) - t_closest * t_closest;\n    float radius_sqr = radius*radius;\n    if (dist_to_center2 > radius_sqr) // If the smallest distance^2 from the ray to center is larger that radius^2, the ray doesn't intersect\n        return false; \n\n    float dist_mid_to_surface = sqrt(radius_sqr - dist_to_center2); \n    float t_surface1 = t_closest - dist_mid_to_surface; // t values at surfaces on both sides\n    float t_surface2 = t_closest + dist_mid_to_surface;\n\n    float t = (t_surface1 < tmin) ? t_surface2 : t_surface1;\n    if (t < t_hit && t > tmin) {\n        t_hit = t;\n        return true;\n    }\n    return false;\n}\n\nbool intersectPlane(vec3 ray_origin, vec3 ray_direction, float offset, vec3 normal, vec3 center, vec2 size, float tmin, inout float t_hit) {\n    vec3 normal_offset = normal * offset;\n    float d = normal_offset.x + normal_offset.y + normal_offset.z;\n    float t = (d - dot(normal, ray_origin)) / dot(normal, ray_direction);\n    \n    if (t < t_hit && t > tmin) {\n        vec3 tmpPos = ray_origin + ray_direction * t;\n        if (size.x + size.y == 0.0 || (\n            tmpPos.x < center.x + size.x*0.5 &&\n            tmpPos.x > center.x - size.x*0.5 &&\n            tmpPos.z < center.z + size.y*0.5 &&\n            tmpPos.z > center.z - size.y*0.5)) {\n            t_hit = t;\n            return true;\n        }\n    }\n    return false;\n}\n\n// Intersects with all of the objects in the world and returns closest hit (note the use of \"out\" arguments)\nbool intersect(vec3 ray_origin,\n            vec3 ray_direction,\n            float t_hit,\n            float tmin,\n            out vec3 position,\n            out vec3 normal,\n            inout vec3 diffuseColor,\n            inout vec3 specularColor,\n            inout vec3 reflectiveColor,\n            inout float roughness,\n            inout bool intersectLight)\n{\n    int intersected = 0;\n    int idx = 0;\n    \n    // Intersect spheres\n    for (int i = 0; i < numSpheres; i++) {\n        if (intersectSphere(ray_origin, ray_direction, sphereCenters[i], 0.8, tmin, t_hit)) {\n            idx = i;\n            intersected = 1;\n        }\n    }\n\n    // Intersect planes\n    for (int i = 0; i < numPlanes; i++) {\n        vec3 planeNormal = planeNormals[i];\n        if (u_enablePlaneBacksides || dot(ray_direction, planeNormal) < 0.0) {\n            if (intersectPlane(ray_origin, ray_direction, planeOffsets[i], planeNormal, vec3(0,0,0), vec2(0,0), tmin, t_hit)) {\n                normal = planeNormal;\n                idx = i;\n                intersected = 2;\n            }\n        }\n    }\n\n    // Intersect lights to make them visible\n    if (intersectLight) {\n        intersectLight = false;\n        for (int i = 0; i < numLights; i++) {\n            vec3 center = lightPos[i];\n            vec2 size = 2.0*lightSize[i];\n            bool tmp = false;\n            if (size.x > 0.0 && size.y > 0.0) // area light\n                tmp = intersectPlane(ray_origin, ray_direction, center.y, vec3(0.0,1.0,0.0), center, size, tmin, t_hit);\n            else // point light\n                tmp = intersectSphere(ray_origin, ray_direction, center, 0.1, tmin, t_hit);\n            if (tmp) {\n                idx = i;\n                intersected = 3;\n            }\n        }\n    }\n\n    position = ray_origin + ray_direction * t_hit;\n\n    // Make only one set of color lookups for each intersection\n    if (intersected == 1) { // Sphere\n        diffuseColor = sphereColors[idx];\n        specularColor = sphereSpecColors[idx];\n        reflectiveColor = reflectiveColors[idx];\n        roughness = sphereRoughness[idx];\n        normal = normalize(position - sphereCenters[idx]);\n        if (dot(normal, -ray_direction) < 0.0) // Backside shading: flip normal if ray and normal are on different sides\n            normal *= -1.0;\n    }\n    else if (intersected == 2) { // Plane\n        if (!u_enablePlaneMirrors) {\n            diffuseColor = planeColors[idx];\n            specularColor = planeSpecular[idx] * vec3(1.0, 1.0, 1.0);\n            reflectiveColor = vec3(0.0);\n            roughness = planeRoughness[idx];\n        } else {\n            diffuseColor = planeColors[idx]*0.01;\n            specularColor = vec3(0.0);\n            reflectiveColor = planeColors[idx];\n            roughness = 1.0;\n        }\n        if (dot(normal, -ray_direction) < 0.0)\n            normal *= -1.0;\n    }\n    else if (intersected == 3) { // Light\n        float cosHalfFOV = cos(0.5*lightSpot[idx].x);\n        vec3 N_light = vec3(0, -1, 0);\n        float cone = (dot(-ray_direction, N_light) > cosHalfFOV) ? 1.0 : 0.0;\n        diffuseColor = cone * u_lightEmission[idx] * 0.1;\n        intersectLight = true;\n    }\n\n    return intersected != 0;\n}\n\n// Faster intersect function for shadows\nbool intersectShadowRay(vec3 ray_origin, vec3 ray_direction, float t_hit) {\n    for (int i = 0; i < numSpheres; i++)\n        if (intersectSphere(ray_origin, ray_direction, sphereCenters[i], 0.8, EPSILON, t_hit))\n            return true;\n    for (int i = 0; i < numPlanes; i++)\n        if (intersectPlane(ray_origin, ray_direction, planeOffsets[i], planeNormals[i], vec3(0.0), vec2(0.0), EPSILON, t_hit))\n            return true;\n    return false;\n}\n\n/**\n *  Sample an area light uniformly.\n *  @param  xform   Position and orientation of the light in 4x4 matrix.\n *  @param  size    Size of the rectangle in 2D.\n *  @return vec3    Sampled position.\n */\nvec3 sampleAreaLightUniform(in vec3 pos, in vec2 size, in vec2 rnd_seed) {\n    float rnd_x = size.x * (random(rnd_seed) * 2.0 - 1.0);\n    float rnd_y = size.y * (random(rnd_seed.yx) * 2.0 - 1.0);\n    return vec3(pos.x + rnd_x, pos.y, pos.z + rnd_y);//(xform * vec4(rnd_x, 0.0, rnd_y, 1.0)).xyz;\n}\n\n/**\n *  Sample an area light uniformly using stratification.\n *  @param  xform       Position and orientation of the light in 4x4 matrix.\n *  @param  size        Size of the rectangle in 2D.\n *  @param  sample_i    Index of current sample.\n *  @return vec3    Sampled position.\n */\nvec3 sampleAreaLightStratified(vec3 pos, vec2 size, vec2 rnd_seed, float sample_i) {\n    float inv_dim = 1.0 / u_directSamplesSqrt;\n    float cell_sizeX = size.x*2.0 * inv_dim;\n    float cell_sizeY = size.y*2.0 * inv_dim;\n    float posX = cell_sizeX * (mod(sample_i, u_directSamplesSqrt) + random(rnd_seed));\n    float posY = cell_sizeY * (floor(sample_i * inv_dim) + random(rnd_seed.yx));\n    return vec3(pos.x - size.x + posX, pos.y, pos.z - size.y + posY);\n}\n\n/**\n *  Compute irradiance intensity from an area light source at a given world point.\n *  @param  PDF The value of the probability density function at the sampled point.\n *  @return float   intersity\n */\nfloat areaLightIrradiance(vec3 L, float L_dist, vec3 N_light, float L_dot_Ns, float cosHalfFOV, float PDF_rcp) {\n    float L_dot_Nl = dot(-L, N_light);\n    float cos_theta_li = max(0.0, L_dot_Nl / (L_dist * 1.0));\n    float cos_theta_i = max(0.0, L_dot_Ns / (L_dist * 1.0));\n\n    float G = cos_theta_li / square(L_dist);\n    float BRDF = 1.0f;\n    \n    // Spotlight effect\n    float cone = (L_dot_Nl > cosHalfFOV) ? 1.0 : 0.0;\n\n    return cone * BRDF * cos_theta_i * G * PDF_rcp;\n}\n\n/**\n *  Compute irradiance intensity from a point light source at a given world point.\n *  Produces soft spotlight edges, as if the light were an area light.\n *  @return float   intersity\n */\nfloat areaPointLightIrradiance(vec3 L, float L_dist, vec3 N_light, float L_dot_Ns, float cosHalfFOV, float PDF_rcp) {\n    float L_dot_Nl = dot(-L, N_light);\n    float cos_theta_li = max(0.0, L_dot_Nl / L_dist);\n    float cos_theta_i = max(0.0, L_dot_Ns / L_dist);\n    \n    // Spotlight effect\n    float cone = max(0.0, min(1.0, 4.0 * (max(0.0, L_dot_Nl) - cosHalfFOV) / (1.0 - cosHalfFOV)));\n\n    return cone * cos_theta_i * cos_theta_li * PDF_rcp / square(L_dist);\n}\n\n/**\n *  Compute irradiance intensity from a point light source at a given world point.\n *  @return float   intersity\n */\nfloat pointLightIrradiance(vec3 L, float L_dist, vec3 N_light, float L_dot_Ns, float cosHalfFOV) {\n    float Pcos = max(0.0, L_dot_Ns ); // Cosine of angle of surface normal and light vector\n    float Lcos = max(0.0, dot(N_light, -L)); // Angle cos of light normal and light vector\n    float attenuation = 1.0/square(L_dist);\n    float cone = max(0.0, min(1.0, 4.0 * (Lcos - cosHalfFOV) / (1.0 - cosHalfFOV)));\n    \n    return PI_RCP * attenuation * Pcos * Lcos * cone;\n}\n\n/** \n *  Phong shading. \n *  Does not take into account if light and normal are on the same side or not.\n *  @param  V   View vector towards surface.\n *  @param  N   Normal of surface.\n *  @param  L   Vector towards light from surface.\n *  @return vec3    Color.\n */\nvec3 shadePhong(vec3 V, vec3 N, vec3 L, vec3 diffuseColor, vec3 specularColor) {\n    vec3 R = reflect(-L, N); // Reflection vector pointing away from object\n    float reflection_intensity = pow(max(0.0, dot(R, -V)), specular_exponent); // Specular intensity depends on how closely the reflection vector points to the camera\n    vec3 specular = specularColor * reflection_intensity;\n\n    return diffuseColor + specular;\n}\n\n/**\n *  Calculates and returns specular and diffuse illumination from all lights on a given point\n *  @return vec3    Color of surface point.\n */\nvec3 directIllumination(vec3 P, vec3 V, vec3 N_surface, vec3 diffuseColor, vec3 specularColor, bool useSampling) {\n    vec3 illuminationColor;\n    \n/// @todo   !!! Split area light and point light calculations !!!\n    for (int i = 0; i < numLights; i++) {\n        vec3 lightPos = lightPos[i];\n        vec3 lightEmission = u_lightEmission[i];\n        vec2 lightSize = lightSize[i];\n        float lightCosHalfFOV = cos(0.5*lightSpot[i].x);\n        vec3 N_light = vec3(0, -1, 0);\n        float PDF_rcp = 1.0f;\n        vec2 rnd = P.xy*P.z;\n\n        bool isAreaLight = useSampling && lightSize.x > 0.0 && lightSize.y > 0.0;\n        if (isAreaLight) {\n            PDF_rcp = 4.0f * lightSize.x * lightSize.y; // Uniform (i.e., constant) probability over the area of the rectangle.\n        }\n\n        int testSamples = isAreaLight ? 5 : 1; // use one sample if calculating pointlights\n        int areaShadowSamples = 0;\n        bool inLight, inShade = false;\n\n        vec3 shading;\n\n        // Get 5 test points to the light (4 corners, 1 center)\n        for (int k = 0; k < testSamples; k++) {\n            if (inLight && inShade) break; // stop asap when there is a discrepancy\n\n            vec3 testPos = lightPos;\n            if (k == 1) { // up left\n                testPos.x -= lightSize.x;\n                testPos.z -= lightSize.y;\n            }\n            else if (k == 2) { // bottom right\n                testPos.x += lightSize.x;\n                testPos.z += lightSize.y;\n            }\n            else if (k == 3) { // up right\n                testPos.x += lightSize.x;\n                testPos.z -= lightSize.y;\n            }\n            else if (k == 4) { // bottom left\n                testPos.x -= lightSize.x;\n                testPos.z += lightSize.y;\n            }\n\n            vec3 L = testPos - P;\n            float L_dist = length(L);\n            L = normalize(L);\n            float L_dot_Ns = dot(L, N_surface);\n            \n            if (L_dot_Ns > 0.0) { // If no light falls to this point, do not check for shadows\n                vec3 irradiance = lightEmission;\n                if (isAreaLight) {\n                    irradiance *= areaLightIrradiance(L, L_dist, N_light, L_dot_Ns, lightCosHalfFOV, PDF_rcp);\n                } else {\n                    irradiance *= areaPointLightIrradiance(L, L_dist, N_light, L_dot_Ns, lightCosHalfFOV, PDF_rcp);\n                }\n\n                if (any(greaterThan(irradiance, vec3(0.001))) && !intersectShadowRay(P, L, L_dist)) {\n                    shading += irradiance * shadePhong(V, N_surface, L, diffuseColor, specularColor);\n                    inLight = true;\n                } else {\n                    inShade = true;\n                }\n            } else {\n                inShade = true;\n            }\n\n            areaShadowSamples++;\n        }\n\n        // If after 5 test samples there is atleast one ray that doesn't reach light and one that reaches the light, the point should have more accurate shading (shadow edges)\n        if (isAreaLight && inLight && inShade) {\n            areaShadowSamples = u_directSamples;\n            shading = vec3(0.0); // Start the sampling over, because keeping the results of regular sampling would produce banding\n            \n            for (int k = 0; k < areaShadowSamples; k++) {\n                vec3 Pl = sampleAreaLightStratified(lightPos, lightSize, rnd, float(k));\n                vec3 L = Pl - P;\n                float L_dist = length(L);\n                L = normalize(L);\n                \n                if (!intersectShadowRay(P, L, L_dist)) {\n                    float L_dot_Ns = dot(L, N_surface);\n                    vec3 irradiance = lightEmission * areaLightIrradiance(L, L_dist, N_light, L_dot_Ns, lightCosHalfFOV, PDF_rcp);\n                    shading += irradiance * shadePhong(V, N_surface, L, diffuseColor, specularColor);\n                }\n            }\n        }\n\n        illuminationColor += shading / float(areaShadowSamples);\n    }\n    return illuminationColor;\n}\n\n// Faster direct illumination calculation with one sample\nvec3 directIlluminationFast(vec3 P, vec3 N_surface, vec3 diffuseColor) {\n    vec3 illuminationColor;\n\n    // Add direct lighting from each light\n    // stops the calculations asap using many conditionals\n    // nested if's seem to have better performance than continues, but break's would give best perf (with one light)\n    for (int i = 0; i < numLights; i++) {\n        vec3 L = lightPos[i] - P;\n        float L_dist = length(L);\n        L = normalize(L);\n        float L_dot_Ns = dot(L, N_surface);\n        \n        if (L_dot_Ns > 0.0) {\n            vec2 lightSize = lightSize[i];\n            vec3 N_light = vec3(0, -1, 0);\n            float lightCosHalfFOV = cos(0.5*lightSpot[i].x);\n            float PDF_rcp = (lightSize.x > 0.0 && lightSize.y > 0.0) ? 4.0f * lightSize.x * lightSize.y : 1.0f;\n            \n            vec3 irradiance = u_lightEmission[i] * areaPointLightIrradiance(L, L_dist, N_light, L_dot_Ns, lightCosHalfFOV, PDF_rcp);\n\n            if (any(greaterThan(irradiance, vec3(0.001))) && !intersectShadowRay(P, L, L_dist)) {\n                illuminationColor += irradiance * diffuseColor;\n            }\n        }\n    }\n\n    return illuminationColor;\n}\n\nfloat G1_Smith(float alpha_sqr, float NdotL) {\n    return 2.0 * NdotL / (NdotL + sqrt(alpha_sqr + (1.0 - alpha_sqr) * square(NdotL)));\n}\n\n// Algorithm: http://jcgt.org/published/0007/04/01/\n// & https://github.com/NVIDIA/Q2RTX/issues/40\nvec3 importanceSampleGGX_VNDF(vec2 u, float alpha, vec3 V, mat3 basis) {\n    vec3 Ve = -vec3(dot(V, basis[0]), dot(V, basis[2]), dot(V, basis[1]));\n    vec3 Vh = normalize(vec3(alpha * Ve.x, alpha * Ve.y, Ve.z));\n    \n    float lensq = square(Vh.x) + square(Vh.y);\n    vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1.0, 0.0, 0.0);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(u.x);\n    float phi = 2.0 * PI * u.y;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - square(t1)) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - square(t1) - square(t2))) * Vh;\n\n    // Tangent space H\n    vec3 Ne = vec3(alpha * Nh.x, max(0.0, Nh.z), alpha * Nh.y);\n\n    // World space H\n    return normalize(basis * Ne);\n}\n\n/** \n *  Calculates indirect illumination with Monte Carlo sampling for metallic surfaces.\n *  Uses VNDF importance sampling to model GGX BRDF.\n *  Uses only one bounce due to exponential performance hit.\n * \n *  @param  P           Point at which lighting is calculated.\n *  @param  V           Direction of ray (towards P).\n *  @param  N           Surface normal at P.\n *  @param  diffuse     Diffuse color of surface at P\n *  @param  roughness   Non squared roughness of surface at P [0,1]\n *\n *  @return vec3    indirect light at P\n */\nvec3 indirectIlluminationGGX(vec3 P, vec3 V, vec3 N, vec3 diffuse, float roughness) {\n    vec3 indirect_sampling_sum;\n    mat3 basis = construct_ONB_frisvad(N);\n    float VNDF_alpha = square(roughness);\n    float G1_alpha = square(square(max(roughness, 0.02)));\n\n    for (int i = 0; i < u_indirectSamples; i++) {\n\t\tvec3 H = importanceSampleGGX_VNDF(vec2(random(P.xz), random(P.xy)), VNDF_alpha, V, basis);\n\t\tvec3 R = reflect(V, H);\n        float NoR = max(0.0, dot(N, R));\n        float G1_NoR = G1_Smith(G1_alpha, NoR);\n        R = normalize(R);\n\n        vec3 P2, N2, diffuse2, specular2, reflective2;\n        float roughness2;\n        bool intersectLight = true;\n        \n        // Intersect the bounced ray\n        // Add lighting from the secondary hit point\n        if (intersect(P, R, 20.0, EPSILON, P2, N2, diffuse2, specular2, reflective2, roughness2, intersectLight))\n            indirect_sampling_sum += intersectLight ? diffuse2 : G1_NoR * directIlluminationFast(P2, N2, diffuse2+reflective2);\n    }\n    // Return the scaled indirect light\n    return ((indirect_sampling_sum*u_rcp_indirectSamples) * diffuse);\n}\n\n// Forms an orthogonal matrix with N as the last column, i.e.,\n// a coordinate system aligned such that N is its local z axis.\nmat3 formBasis(vec3 N) {\n    vec3 Nt;\n    if (abs(N.x) > abs(N.y)) \n        Nt = vec3(N.z, 0.0, -N.x) / sqrt(N.x * N.x + N.z * N.z); \n    else \n        Nt = vec3(0.0, -N.z, N.y) / sqrt(N.y * N.y + N.z * N.z); \n    vec3 Nb = cross(N, Nt);\n\n    return mat3(Nt, Nb, N);\n}\n\n// Get random cosine-weighted point (direction) on a hemisphere.\nvec3 cosineHemisphereDir(vec2 rand) {\n    // https://blog.thomaspoulet.fr/uniform-sampling-on-unit-hemisphere/\n    float m = 1.0;\n    float theta = acos(pow(1.0-random(rand), 1.0/(1.0+m)));\n    float phi = 2.0 * PI * random(rand.yx);\n    vec2 diskXY = vec2(sin(theta)*cos(phi), sin(theta)*sin(phi));\n    \n    return vec3(diskXY, sqrt(1.0f - pow(diskXY.x, 2.0f) - pow(diskXY.y, 2.0f)));\n}\n\n// Get semi-random point in unit sphere using fibonacci spiral (https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere)\nvec3 fibonacciSphereDir(vec2 rand, float sampleIdx, float inv_samples, float jitter_scale) {\n    float y = (1.0 - sampleIdx * inv_samples * 2.0) + (random(rand)*5.0-2.5)*jitter_scale; // y goes from 1 to -1 (with added jitter)\n    float radius = sqrt(1.0 - y*y); // radius at y\n    float theta = (PHI * sampleIdx) + (random(rand)*10.0-5.0)*jitter_scale; // golden angle increment in spiral (with added jitter)\n    return vec3(cos(theta)*radius, y, sin(theta)*radius);\n}\n\n// Same as indirectGGX, but optimized for fully diffuse surfaces\nvec3 indirectIlluminationLambert(vec3 P, vec3 V, vec3 N, vec3 diffuseColor) {\n    vec3 indirect_sampling_sum;\n    //vec3 mirrorDir = reflect(V, N);\n    vec2 rand = P.yx*P.z;\n    mat3 B = formBasis(N);\n\n    for (int i = 0; i < u_indirectSamples; i++) {\n        // Direction is calculated with Lambert's cosine law (https://raytracing.github.io/books/RayTracingInOneWeekend.html#diffusematerials)\n        //vec3 diffuseDir = normalize(N + fibonacciSphereDir(rand, float(i)+0.5, u_rcp_indirectSamples, u_indirectJitterScale));\n        //vec3 R = normalize(mix(mirrorDir, diffuseDir, 1.0));\n        vec3 R = normalize(B * cosineHemisphereDir(rand));\n\n        vec3 P2, N2, diffuse2, specular2, reflective2;\n        float roughness2;\n        bool intersectLight = false;\n\n        if (intersect(P, R, 10.0, EPSILON, P2, N2, diffuse2, specular2, reflective2, roughness2, intersectLight))\n            indirect_sampling_sum += directIlluminationFast(P2, N2, diffuse2+reflective2);\n    }\n    return indirect_sampling_sum * u_rcp_indirectSamples * diffuseColor;\n}\n\n// Calculates and returns mirror reflections on a given point\nvec3 reflectionIllumination(vec3 P, vec3 V, vec3 N, vec3 reflectiveColor) {\n    vec3 reflectionSum;\n    for (int i = 0; i < u_reflectionBounces; i++) {\n        if (reflectiveColor.x + reflectiveColor.y + reflectiveColor.z == 0.0) break; // Stop if we reach max number of bounces or hit material that is not reflective\n\n        V = reflect(V, N); // Get the direction of the reflected ray\n        \n        vec3 P2, diffuse2, specular2, reflective2;\n        float roughness2;\n        bool intersectLight = true;\n\n        // Trace the reflected ray and add the result to pixel\n        if (!intersect(P, V, 20.0, EPSILON, P2, N, diffuse2, specular2, reflective2, roughness2, intersectLight))\n            break;\n        \n        vec3 mirror_sample_color = intersectLight ? diffuse2 : directIllumination(P2, V, N, diffuse2, specular2, true);\n        \n        if (u_enableRefGI) // Add indirect illumination to reflection\n            mirror_sample_color += indirectIlluminationLambert(P2, V, N, diffuse2);\n        else\n            mirror_sample_color += ambientLight * diffuse2;\n\n        P = P2;\n        reflectionSum += mirror_sample_color * reflectiveColor;\n        reflectiveColor = reflective2 * reflectiveColor;  // Successive ray colors are affected by each reflective surface's color\n    }\n    return reflectionSum;\n}\n          \nvec3 LinearToSRGB(vec3 rgb) {     \n    return mix(\n        pow(rgb, vec3(1.0 / 2.2)) * 1.055 - 0.055,\n        rgb * 12.92,\n        LessThan(rgb, 0.0031308)\n    );\n}\n\nvec3 ACESFilm(vec3 x) {\n    x = ACESInputMat * x;\n    vec3 a = x * (x + 0.0245786) - 0.000090537;\n    vec3 b = x * (0.983729 * x + 0.4329510) + 0.238081;\n    x = a / b;\n    x = ACESOutputMat * x;\n    return clamp(x, 0.0, 1.0);\n}\n\n// Color accumulation with moving exponential average\nvec3 accumulateTAA(vec3 pixelColor) {\n    if (u_runTAA)\n        return mix(texture(u_accumTexture, texCoord).rgb, pixelColor, u_taaBlendFactor);\n    else\n        return pixelColor;\n}\n\nvoid main() {\n    vec3 ray_dir = normalize(ray);\n    float hit_dist = length(ray); // The far clipping distance\n    vec3 pixelColor, diffuseColor, specularColor, reflectiveColor, normal, point;\n    float roughness;\n    bool intersectLight = true;\n    randomIncrement = u_randomseed;\n\n    // intersect the ray with objects (tmin is 0, because vertex shader places the origin of the ray in near clipping distance)\n    if (!intersect(origin, ray_dir, hit_dist, 0.0, point, normal, diffuseColor, specularColor, reflectiveColor, roughness, intersectLight)) {\n        out_accumulateColor = vec4(accumulateTAA(vec3(0.0)), 1.0);\n        out_finalColor = out_accumulateColor;\n        return;\n    }\n\n    // If the ray hit a light, return its color because it doesn't have any other properties than surface color\n    if (intersectLight) {\n        pixelColor = min(diffuseColor, vec3(1.0));\n        out_accumulateColor = vec4(accumulateTAA(pixelColor), 1.0);\n        out_finalColor = out_accumulateColor;\n        return;\n    }\n\n    // Ambient light\n    if (!u_enableGI)\n        pixelColor += ambientLight * diffuseColor;\n\n    // ==== DIRECT ILLUMINATION ====\n    // For GGX surfaces direct illumination may or may not be added; currently scale the amount by roughness\n    // Details for conductors and dielectrics in: https://google.github.io/filament/Filament.html#figure_dielectricconductor\n    pixelColor += roughness * directIllumination(point, ray_dir, normal, diffuseColor, specularColor, true);\n\n    // ==== INDIRECT ILLUMINATION ====\n    if (u_enableGI && diffuseColor.r > 0.0 && diffuseColor.g > 0.0 && diffuseColor.b > 0.0) {\n        if (roughness < 1.0) // GGX is much slower, so use it only when needed\n            pixelColor += indirectIlluminationGGX(point, ray_dir, normal, diffuseColor, roughness);\n        else\n            pixelColor += indirectIlluminationLambert(point, ray_dir, normal, diffuseColor);\n    }\n        \n    // ==== MIRROR REFLECTION ====\n    if (u_reflectionBounces > 0 && length(reflectiveColor) > 0.0)\n        pixelColor += reflectionIllumination(point, ray_dir, normal, reflectiveColor);\n\n    // ==== POST FX & OUTPUT ====\n    // Accumulate in linear light. Produces correct averages, but breaks TAA for highlights when clipped back to [0,1].\n    pixelColor = accumulateTAA(pixelColor);\n    out_accumulateColor = vec4(pixelColor, 1.0);\n\n    // ACES tonemapping (source: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl)\n    pixelColor = ACESFilm(pixelColor);\n    pixelColor = LinearToSRGB(pixelColor);\n    out_finalColor = vec4(pixelColor, 1.0);\n}");console.log("CREATING PROGRAM"),s(e,1280,720),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT);var o=function(e,n,t){var r=e.createProgram();if(e.attachShader(r,n),e.attachShader(r,t),e.linkProgram(r),e.getProgramParameter(r,e.LINK_STATUS))return r;console.log(e.getProgramInfoLog(r)),e.deleteProgram(r)}(e,r,i);return e.useProgram(o),console.log("FINISH"),o}(R),z=R.getUniformLocation(w,"u_runTAA"),F=R.getUniformLocation(w,"u_enableGI"),M=R.getUniformLocation(w,"u_enableRefGI"),k=(R.getUniformLocation(w,"u_enableTonemapping"),R.getUniformLocation(w,"u_enableGammaCorrection"),R.getUniformLocation(w,"u_enablePlaneBacksides")),U=R.getUniformLocation(w,"u_enablePlaneMirrors"),D=R.getUniformLocation(w,"u_randomseed"),B=R.getUniformLocation(w,"u_taaBlendFactor"),O=R.getUniformLocation(w,"u_directSamples"),G=R.getUniformLocation(w,"u_directSamplesSqrt"),X=R.getUniformLocation(w,"u_indirectSamples"),H=R.getUniformLocation(w,"u_rcp_indirectSamples"),V=R.getUniformLocation(w,"u_reflectionBounces"),q=R.getUniformLocation(w,"u_accumTexture"),j=(R.getUniformLocation(w,"sphereCenters[0]"),R.createFramebuffer());R.bindFramebuffer(R.FRAMEBUFFER,j);var Y=l(R);R.texImage2D(R.TEXTURE_2D,0,R.RGBA32F,R.canvas.width,R.canvas.height,0,R.RGBA,R.FLOAT,null),R.framebufferTexture2D(R.FRAMEBUFFER,R.COLOR_ATTACHMENT0,R.TEXTURE_2D,Y,0);var W=l(R);R.texImage2D(R.TEXTURE_2D,0,R.RGBA32F,R.canvas.width,R.canvas.height,0,R.RGBA,R.FLOAT,null),R.framebufferTexture2D(R.FRAMEBUFFER,R.COLOR_ATTACHMENT1,R.TEXTURE_2D,W,0),R.drawBuffers([R.COLOR_ATTACHMENT0,R.COLOR_ATTACHMENT1]),R.readBuffer(R.COLOR_ATTACHMENT0);var K=R.createFramebuffer();R.bindFramebuffer(R.FRAMEBUFFER,K),R.bindTexture(R.TEXTURE_2D,Y),R.framebufferTexture2D(R.FRAMEBUFFER,R.COLOR_ATTACHMENT0,R.TEXTURE_2D,Y,0);var Z=l(R);R.texImage2D(R.TEXTURE_2D,0,R.RGBA32F,R.canvas.width,R.canvas.height,0,R.RGBA,R.FLOAT,null),R.framebufferTexture2D(R.FRAMEBUFFER,R.COLOR_ATTACHMENT1,R.TEXTURE_2D,Z,0),R.drawBuffers([R.COLOR_ATTACHMENT0,R.COLOR_ATTACHMENT1]),R.readBuffer(R.COLOR_ATTACHMENT0);var J=[null,null,null,null,null],Q=0;function $(e){var n=(Q+1)%5;if((null!=J[n]?R.getSyncParameter(J[n],R.SYNC_STATUS):R.SIGNALED)==R.SIGNALED)return J[Q=n]=R.fenceSync(R.SYNC_GPU_COMMANDS_COMPLETE,0),void(e?requestAnimationFrame(ee):Promise.resolve(1).then(ee));setTimeout($,0)}function ee(){var n=performance.now();S=(n-E)/1e3,E=n;var t=_||b||y||x||L;t&&(Se(S),_=!1);var r,i,a,l,s,c,d=p;v&&p&&(v=!1,d=!1,P=1),d&&(r=1/R.canvas.width,i=1/R.canvas.height,1,0,0,0,0,1,0,0,0,0,1,0,l=(2*f[A][0]-1)*r,s=(2*f[A][1]-1)*i,0,1,(c=new e(16))[0]=1,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=1,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[10]=1,c[11]=0,c[12]=l,c[13]=s,c[14]=0,c[15]=1,o(a=c,Le,a),R.uniformMatrix4fv(R.getUniformLocation(w,"invprojview"),!1,a),A++),(!d||A>=u)&&(A=0);var m=!t&&d;if(R.uniform1i(z,d),R.uniform1f(D,Math.random()),p){var I=g?j:K;R.bindFramebuffer(R.FRAMEBUFFER,I),R.bindTexture(R.TEXTURE_2D,g?Z:W),R.clearColor(0,0,0,1),R.clear(R.COLOR_BUFFER_BIT),R.uniform1i(q,0),R.uniform1f(B,1/P),R.drawArrays(R.TRIANGLES,0,3),m&&P%Math.max(1,Math.floor(C/30))!=0||(R.bindFramebuffer(R.READ_FRAMEBUFFER,I),R.bindFramebuffer(R.DRAW_FRAMEBUFFER,null),R.blitFramebuffer(0,0,R.canvas.width,R.canvas.height,0,0,R.canvas.width,R.canvas.height,R.COLOR_BUFFER_BIT,R.NEAREST)),g=!g}else R.bindFramebuffer(R.DRAW_FRAMEBUFFER,null),R.drawArrays(R.TRIANGLES,0,3);P++,N++;var F=(n-T)/1e3;F>=.5&&(T=n,C=N/F,h.innerText=Math.round(C),m||(h.innerText+=" (VSync)"),N=0),$(!m)}var ne=!0,te=!0,re=10,ie=1,oe=!0,ae=4,le=!0,se=!1,ce=c.nS.On,ue=c.nS.NC,fe=c.nS.Bp,de=c.nS.x,me=c.nS.y,he=c.nS.z,ge=c.nS.fx,pe=c.nS.tW,ve=t(),_e=t(),be=t(),ye=t(),xe=t(),Le=t();function Se(e){var n,t,a,l;b&&(de+=4*e*Math.cos(pe)*Math.cos(ge+Math.PI/2),me+=4*e*Math.sin(pe),he-=4*e*Math.cos(pe)*Math.sin(ge+Math.PI/2)),x&&(de-=4*e*Math.cos(pe)*Math.cos(ge+Math.PI/2),me-=4*e*Math.sin(pe),he+=4*e*Math.cos(pe)*Math.sin(ge+Math.PI/2)),y&&(de+=4*e*Math.cos(ge+Math.PI),he-=4*e*Math.sin(ge+Math.PI)),L&&(de+=4*e*Math.cos(ge),he-=4*e*Math.sin(ge)),i(ve,fe,R.canvas.width/R.canvas.height,ce,ue),n=_e,t=ge,a=Math.sin(t),l=Math.cos(t),n[0]=l,n[1]=0,n[2]=-a,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=a,n[9]=0,n[10]=l,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,function(e,n){var t=Math.sin(n),r=Math.cos(n);e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=t,e[7]=0,e[8]=0,e[9]=-t,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(be,pe),function(e,n){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1}(ye,[de,me,he]),o(xe,_e,be),o(xe,ye,xe),r(xe,xe),o(Le,ve,xe),r(Le,Le),R.uniform1f(R.getUniformLocation(w,"near"),ce),R.uniform1f(R.getUniformLocation(w,"far"),ue),R.uniformMatrix4fv(R.getUniformLocation(w,"invprojview"),!1,Le),v=!0}function Ee(){for(var e=[],n=0;n<c.Rm.length;n++)c.Rm[n].enabled&&e.push(c.Rm[n]);var t=e.length;R.uniform1i(R.getUniformLocation(w,"numPlanes"),t);for(var r=0;r<t;r++){var i=R.getUniformLocation(w,"planeOffsets["+r+"]"),o=R.getUniformLocation(w,"planeNormals["+r+"]"),a=R.getUniformLocation(w,"planeColors["+r+"]"),l=R.getUniformLocation(w,"planeSpecular["+r+"]"),s=R.getUniformLocation(w,"planeRoughness["+r+"]");R.uniform1f(i,e[r].offset),R.uniform3f(o,e[r].x,e[r].y,e[r].z),R.uniform3f(a,e[r].r,e[r].g,e[r].b),R.uniform1f(l,e[r].specular),R.uniform1f(s,e[r].roughness)}v=!0}function Ce(){var e=c.H.filter((function(e){return e.enabled})),n=e.length;R.uniform1i(R.getUniformLocation(w,"numLights"),n);for(var t=0;t<n;t++){var r=e[t],i=R.getUniformLocation(w,"lightPos["+t+"]"),o=R.getUniformLocation(w,"lightSize["+t+"]"),a=R.getUniformLocation(w,"u_lightEmission["+t+"]"),l=R.getUniformLocation(w,"lightSpot["+t+"]");R.uniform3f(i,r.x,r.y,r.z),R.uniform2f(o,oe?r.sizeX:0,oe?r.sizeY:0),R.uniform3f(a,r.r*r.brightness,r.g*r.brightness,r.b*r.brightness),R.uniform2f(l,r.spotSize,r.spotIntensity)}v=!0}function Te(){R.uniform3f(R.getUniformLocation(w,"ambientLight"),.01,.01,.01),R.uniform1i(F,ne),R.uniform1i(M,te),R.uniform1i(k,le),R.uniform1i(U,se);var e=Math.floor(Math.sqrt(ae));R.uniform1f(G,e),R.uniform1i(O,Math.pow(e,2)),R.uniform1i(X,re),R.uniform1f(H,1/re),R.uniform1i(V,ie),v=!0}function Ne(){I.style.width=window.innerWidth,I.style.height=window.innerHeight;var e=Math.floor(window.innerWidth*window.devicePixelRatio),n=Math.floor(window.innerHeight*window.devicePixelRatio);R.bindTexture(R.TEXTURE_2D,Y),R.texImage2D(R.TEXTURE_2D,0,R.RGBA32F,e,n,0,R.RGBA,R.FLOAT,null),R.bindTexture(R.TEXTURE_2D,null),R.bindTexture(R.TEXTURE_2D,W),R.texImage2D(R.TEXTURE_2D,0,R.RGBA32F,e,n,0,R.RGBA,R.FLOAT,null),R.bindTexture(R.TEXTURE_2D,null),R.bindTexture(R.TEXTURE_2D,Z),R.texImage2D(R.TEXTURE_2D,0,R.RGBA32F,e,n,0,R.RGBA,R.FLOAT,null),R.bindTexture(R.TEXTURE_2D,null),s(R,e,n),Se(),P=1}function Pe(e,n){var t=document.getElementById("lightcontrols"),r="\n        <br>\n        <b>light ".concat(e+1,'</b><br>\n        <input type="checkbox" ').concat(n[e].enabled&&"checked",' id="').concat(e,'" class="light-enable"> on/off<br>\n        <table class="sliders">\n            <tr>\n                <td><label>Bright:</label></td>\n                <td><input type="range" min="0" max="5" step="0.01" value="').concat(Math.log10(n[e].brightness),'" id="').concat(e,'" class="light-brightness"></td>\n            </tr>\n            <tr>\n                <td><label>Spot cone:</label></td>\n                <td><input type="range" min="0" max="3.15" step="0.01" value="').concat(n[e].spotSize,'" id="').concat(e,'" class="light-spotsize"></td>\n            </tr>\n            <tr>\n                <td><label>r:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(e,'r" class="light-color"></td>\n            </tr>\n            <tr>\n                <td><label>g:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(e,'g" class="light-color"></td>\n            </tr>\n            <tr>\n                <td><label>b:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(e,'b" class="light-color"></td>\n            </tr>\n                <td><label>sizeX:</label></td>\n                <td><input type="range" min="0" max="3" step="0.01" value="').concat(n[e].sizeX,'" id="').concat(e,'x" class="light-size"></td>\n            <tr>\n                <td><label>sizeY:</label></td>\n                <td><input type="range" min="0" max="3" step="0.01" value="').concat(n[e].sizeY,'" id="').concat(e,'y" class="light-size"></td>\n            </tr>\n        </table>');t.insertAdjacentHTML("beforeend",r)}function Ae(e,n){var t=document.getElementById("planecontrols"),r='\n        <input type="checkbox" id="'.concat(e,'" class="plane-enable" ').concat(n[e].enabled&&"checked","><b>").concat(n[e].desc,"</b><br>");t.insertAdjacentHTML("beforeend",r)}Ne(),Ee(),function(){var e=c.vi.length;R.uniform1i(R.getUniformLocation(w,"numSpheres"),e);for(var n=0;n<e;n++){var t=c.vi[n],r=R.getUniformLocation(w,"sphereCenters["+n+"]"),i=R.getUniformLocation(w,"sphereColors["+n+"]"),o=R.getUniformLocation(w,"reflectiveColors["+n+"]"),a=R.getUniformLocation(w,"sphereSpecColors["+n+"]"),l=R.getUniformLocation(w,"sphereRoughness["+n+"]");R.uniform3f(r,t.x,t.y,t.z),R.uniform3f(i,t.r,t.g,t.b),R.uniform3f(o,t.rr,t.rg,t.rb),R.uniform3f(a,t.sr,t.sg,t.sb),R.uniform1f(l,t.roughness)}v=!0}(),Ce(),Te(),ee();for(var Ie=0;Ie<c.H.length;Ie++)Pe(Ie,c.H);for(var Re=0;Re<c.Rm.length;Re++)Ae(Re,c.Rm);function we(e,n){switch(e){case"KeyW":b=n;break;case"KeyS":x=n;break;case"KeyA":y=n;break;case"KeyD":L=n}}window.addEventListener("resize",Ne),document.addEventListener("mousedown",(function(e){e.target.closest(".controls")||2==e.button&&(document.pointerLockElement===e.target?document.exitPointerLock():e.target.requestPointerLock())})),document.addEventListener("mousemove",(function(e){var n;"canvas"===(null===(n=document.pointerLockElement)||void 0===n?void 0:n.id)&&(ge-=.0015*e.movementX,pe-=.0015*e.movementY,_=!0)})),document.addEventListener("keydown",(function(e){return we(e.code,!0)})),document.addEventListener("keyup",(function(e){return we(e.code,!1)})),document.getElementById("enableUI").addEventListener("input",(function(e){document.getElementsByClassName("controls")[0].style.display=e.target.checked?"block":"none"})),document.getElementById("enableTAA").addEventListener("input",(function(e){p=e.target.checked,Ne()})),document.getElementById("enableGI").addEventListener("input",(function(e){ne=e.target.checked,Te()})),document.getElementById("enableRefGI").addEventListener("input",(function(e){te=e.target.checked,Te()}));var ze=document.getElementById("indirectsamples");ze.addEventListener("input",(function(e){re=e.target.value,ze.nextElementSibling.value=e.target.value,Te()})),document.getElementById("directsamples").addEventListener("input",(function(e){ae=e.target.value*e.target.value,Te()})),document.getElementById("reflectionbounces").addEventListener("input",(function(e){ie=e.target.value,Te()})),document.getElementById("fov").addEventListener("input",(function(e){var t;t=e.target.value,fe=t*n,Se()})),document.getElementById("arealightsenable").addEventListener("input",(function(e){oe=e.target.checked,Ce()})),document.querySelectorAll(".light-enable").forEach((function(e){e.addEventListener("input",(function(e){c.H[e.target.id].enabled=e.target.checked,Ce()}))})),document.querySelectorAll(".light-brightness").forEach((function(e){e.addEventListener("input",(function(e){c.H[e.target.id].brightness=Math.pow(10,e.target.value),Ce()}))})),document.querySelectorAll(".light-spotsize").forEach((function(e){e.addEventListener("input",(function(e){c.H[e.target.id].spotSize=e.target.value,Ce()}))})),document.querySelectorAll(".light-spotintensity").forEach((function(e){e.addEventListener("input",(function(e){c.H[e.target.id].spotIntensity=e.target.value,Ce()}))})),document.querySelectorAll(".light-color").forEach((function(e){e.addEventListener("input",(function(e){var n=c.H[e.target.id[0]];"r"===e.target.id[1]?n.r=e.target.value:"g"===e.target.id[1]?n.g=e.target.value:"b"===e.target.id[1]&&(n.b=e.target.value),Ce()}))})),document.querySelectorAll(".light-size").forEach((function(e){e.addEventListener("input",(function(e){var n=c.H[e.target.id[0]];"x"===e.target.id[1]?n.sizeX=e.target.value:"y"===e.target.id[1]&&(n.sizeY=e.target.value),Ce()}))})),document.querySelectorAll(".plane-enable").forEach((function(e){e.addEventListener("input",(function(e){c.Rm[e.target.id].enabled=e.target.checked,Ee()}))})),document.getElementById("planebacksides").addEventListener("input",(function(e){le=e.target.checked,Te()})),document.getElementById("enablemirrorworld").addEventListener("input",(function(e){se=e.target.checked,le=!1,document.getElementById("planebacksides").checked=!1;for(var n=0;n<c.Rm.length;n++)c.Rm[n].enabled=!0;document.querySelectorAll(".plane-enable").forEach((function(e){e.checked=!0})),te=!1,document.getElementById("enableRefGI").checked=!1,ie=5,document.getElementById("reflectionbounces").value=5,document.getElementById("reflectionbounces").nextElementSibling.value=5,Ee(),Te()})),document.getElementById("increasedlimits").addEventListener("input",(function(e){document.getElementById("indirectsamples").setAttribute("max",200),document.getElementById("reflectionbounces").setAttribute("max",100),document.getElementById("fov").setAttribute("max",179),document.getElementById("fov").setAttribute("min",.01),document.getElementById("fov").setAttribute("step",.01)}))})(),e=p(379),n=p.n(e),t=p(795),r=p.n(t),i=p(569),o=p.n(i),a=p(565),l=p.n(a),s=p(216),c=p.n(s),u=p(589),f=p.n(u),d=p(424),(m={}).styleTagTransform=f(),m.setAttributes=l(),m.insert=o().bind(null,"head"),m.domAPI=r(),m.insertStyleElement=c(),n()(d.Z,m),d.Z&&d.Z.locals&&d.Z.locals})();